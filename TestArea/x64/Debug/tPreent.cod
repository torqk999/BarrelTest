; Listing generated by Microsoft (R) Optimizing Compiler Version 19.39.33523.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__9C67CA7D_tEnums@h DB 01H
__EAEE5CFA_tDefines@h DB 01H
__0ED14FEE_winpackagefamily@h DB 01H
__F92EF742_winapifamily@h DB 01H
__22E515EB_sdkddkver@h DB 01H
__FE09AF47_concurrencysal@h DB 01H
__C073CA79_sal@h DB 01H
__D6AFE870_vadefs@h DB 01H
__D63E96CF_vcruntime@h DB 01H
__514B86D7_excpt@h DB 01H
__9A7D38D9_stdarg@h DB 01H
__29F49F40_specstrings_undef@h DB 01H
__D0F42932_specstrings_strict@h DB 01H
__F00405FD_sdv_driverspecs@h DB 01H
__173E09CA_driverspecs@h DB 01H
__9A452361_specstrings@h DB 01H
__1B0272D9_corecrt@h DB 01H
__74484FB3_corecrt_wctype@h DB 01H
__1EC467ED_ctype@h DB 01H
__98517906_kernelspecs@h DB 01H
__D3497022_basetsd@h DB 01H
__61CC25A1_errno@h DB 01H
__3EADF068_vcruntime_string@h DB 01H
__E4C945B4_corecrt_memcpy_s@h DB 01H
__8EAFF484_corecrt_memory@h DB 01H
__6490AEC5_corecrt_wstring@h DB 01H
__E8295E1E_string@h DB 01H
__7FCB5136_guiddef@h DB 01H
__FF8A9E11_pshpack4@h DB 01H
__D5438902_poppack@h DB 01H
__FB07E2A3_pshpack2@h DB 01H
__F6906775_pshpack8@h DB 01H
__F9415CFA_pshpack1@h DB 01H
__E58C6F1C_apiset@h DB 01H
__A5C52262_ktmtypes@h DB 01H
__FBBA8F9D_winnt@h DB 01H
__A32D3D2C_minwindef@h DB 01H
__7D798299_windef@h DB 01H
__9AE108E9_apisetcconv@h DB 01H
__9CE53D2C_minwinbase@h DB 01H
__5D0AA210_apiquery2@h DB 01H
__4DD4E726_processenv@h DB 01H
__3575CC96_fileapi@h DB 01H
__8EA220E6_fileapifromapp@h DB 01H
__BF9B31FE_debugapi@h DB 01H
__C3AFE134_utilapiset@h DB 01H
__76F69E51_handleapi@h DB 01H
__7E63D784_errhandlingapi@h DB 01H
__FFA7003C_fibersapi@h DB 01H
__8971CECF_namedpipeapi@h DB 01H
__46C9D8A6_profileapi@h DB 01H
__98D4F0A3_heapapi@h DB 01H
__50EF2A88_ioapiset@h DB 01H
__92EA1464_synchapi@h DB 01H
__A53D8AED_interlockedapi@h DB 01H
__B506CAAF_processthreadsapi@h DB 01H
__FF735694_sysinfoapi@h DB 01H
__29589789_memoryapi@h DB 01H
__E9C7A663_enclaveapi@h DB 01H
__D035F9F7_threadpoollegacyapiset@h DB 01H
__C899130C_threadpoolapiset@h DB 01H
__E0441EE7_jobapi@h DB 01H
__CEF86838_jobapi2@h DB 01H
__35AC6B9A_wow64apiset@h DB 01H
__C8AE41A5_libloaderapi@h DB 01H
__CC9E232D_securitybaseapi@h DB 01H
__C9D0C9B8_namespaceapi@h DB 01H
__30FF9CAD_systemtopologyapi@h DB 01H
__4D358795_processtopologyapi@h DB 01H
__40446D10_securityappcontainer@h DB 01H
__3A952EDF_realtimeapiset@h DB 01H
__F4865F4B_winerror@h DB 01H
__53C1BD93_timezoneapi@h DB 01H
__1FFBEDBF_winbase@h DB 01H
__43D3FA34_wingdi@h DB 01H
__D24A7391_tvout@h DB 01H
__7713A6C8_winuser@h DB 01H
__0B345F71_datetimeapi@h DB 01H
__9AC6960C_winnls@h DB 01H
__973A40A8_stringapiset@h DB 01H
__CC46FEE2_wincontypes@h DB 01H
__97D70BE1_consoleapi@h DB 01H
__27EC5E18_consoleapi2@h DB 01H
__262E342F_consoleapi3@h DB 01H
__641DCD70_wincon@h DB 01H
__5A96C7A7_verrsrc@h DB 01H
__B69C6FF2_winver@h DB 01H
__7AEB8C37_reason@h DB 01H
__59F1A8A9_winreg@h DB 01H
__EE0E2B7F_wnnc@h DB 01H
__DCDB7054_winnetwk@h DB 01H
__EDC72EEB_cderr@h DB 01H
__95F9199D_dde@h DB 01H
__66427627_ddeml@h DB 01H
__957C29A0_dlgs@h DB 01H
__12EA15AF_lzexpand@h DB 01H
__62131F15_mmsyscom@h DB 01H
__47E68D49_mciapi@h DB 01H
__5D7DD356_mmiscapi@h DB 01H
__7223D2EF_mmiscapi2@h DB 01H
__A330DBB3_playsoundapi@h DB 01H
__601B366F_mmeapi@h DB 01H
__1134ADD5_timeapi@h DB 01H
__93F2265A_joystickapi@h DB 01H
__DF6EB4E3_mmsystem@h DB 01H
__BD641FCB_nb30@h DB 01H
__DF8704F0_rpcdcep@h DB 01H
__5C6CA7BB_rpcdce@h DB 01H
__853533C4_rpcnsi@h DB 01H
__2D2406C3_rpcnterr@h DB 01H
__64521D71_rpcasync@h DB 01H
__AADCBA08_rpc@h DB 01H
__19E26CFF_shellapi@h DB 01H
__1E9F31D3_winperf@h DB 01H
__832A4112_inaddr@h DB 01H
__32C6F875_winsock@h DB 01H
__7953A3F8_bcrypt@h DB 01H
__E4169492_ncrypt@h DB 01H
__AF3DDDC3_dpapi@h DB 01H
__D1E23BF2_wincrypt@h DB 01H
__82AB4779_winefs@h DB 01H
__1FE431C9_rpcnsip@h DB 01H
__2B741F2D_rpcsal@h DB 01H
__92623256_rpcndr@h DB 01H
__9C18532E_wtypesbase@h DB 01H
__EA2E1D6D_wtypes@h DB 01H
__7DDD9F45_winioctl@h DB 01H
__E550A843_winsmcrd@h DB 01H
__9809C1BA_winscard@h DB 01H
__EA174FA4_prsht@h DB 01H
__0E1BD114_winspool@h DB 01H
__45DED006_corecrt_malloc@h DB 01H
__13F5961F_stddef@h DB 01H
__FD6DBD68_corecrt_search@h DB 01H
__E2E33A61_corecrt_wstdlib@h DB 01H
__10D4A829_limits@h DB 01H
__6E5ACABA_stdlib@h DB 01H
__30B1AFDA_unknwnbase@h DB 01H
__328C1996_objidlbase@h DB 01H
__C4E06B6A_cguid@h DB 01H
__434718C5_combaseapi@h DB 01H
__DE6FDEF1_unknwn@h DB 01H
__CCE0BACC_objidl@h DB 01H
__8C7011E5_oaidl@h DB 01H
__2E0B7863_propidlbase@h DB 01H
__BF4CF2EC_coml2api@h DB 01H
__6D897344_oleidl@h DB 01H
__1129FC2C_servprov@h DB 01H
__757952E4_msxml@h DB 01H
__B1191D53_urlmon@h DB 01H
__404D1A47_propidl@h DB 01H
__A1C63593_objbase@h DB 01H
__C1B0A9CB_oleauto@h DB 01H
__24EAF61F_ole2@h DB 01H
__2B1843DA_commdlg@h DB 01H
__81DDEDE3_stralign@h DB 01H
__2134D1B4_winsvc@h DB 01H
__11C07376_mcx@h DB 01H
__577CE3E7_ime_cmodes@h DB 01H
__1E72C31E_imm@h DB 01H
__63AA7AF5_Windows@h DB 01H
__4EC676C0_tModules@h DB 01H
__AFB9CF29_tPreent@h DB 01H
__386B16A1_tPreent@c DB 01H
msvcjmc	ENDS
PUBLIC	strLenSafe
PUBLIC	pootChar
PUBLIC	pootStr
PUBLIC	integerConvert
PUBLIC	strToInt
PUBLIC	numConvert
PUBLIC	Preent
PUBLIC	GeetCount
PUBLIC	Geet
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BF@CAJJEMJD@?6?$FLNULL?5PARAM?5ERROR?$FN?6@ ; `string'
PUBLIC	__real@0000000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@43e0000000000000
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_GetStdHandle:PROC
EXTRN	__imp_ReadConsoleA:PROC
EXTRN	__imp_WriteConsoleA:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_BSS	SEGMENT
PREENT_BUFFER DB 040H DUP (?)
?iBuffer@?1??integerConvert@@9@9 DB 032H DUP (?)	; `integerConvert'::`2'::iBuffer
	ALIGN	4

?Buffer@?1??numConvert@@9@9 DB 032H DUP (?)		; `numConvert'::`2'::Buffer
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$strLenSafe DD imagerel $LN7
	DD	imagerel $LN7+107
	DD	imagerel $unwind$strLenSafe
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pootChar DD imagerel $LN3
	DD	imagerel $LN3+92
	DD	imagerel $unwind$pootChar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pootStr DD imagerel $LN4
	DD	imagerel $LN4+114
	DD	imagerel $unwind$pootStr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$integerConvert DD imagerel $LN6
	DD	imagerel $LN6+156
	DD	imagerel $unwind$integerConvert
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$strToInt DD imagerel $LN11
	DD	imagerel $LN11+255
	DD	imagerel $unwind$strToInt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$numConvert DD imagerel $LN46
	DD	imagerel $LN46+1416
	DD	imagerel $unwind$numConvert
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Preent DD imagerel $LN28
	DD	imagerel $LN28+787
	DD	imagerel $unwind$Preent
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GeetCount DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$GeetCount
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Geet DD	imagerel $LN3
	DD	imagerel $LN3+117
	DD	imagerel $unwind$Geet
pdata	ENDS
;	COMDAT __real@43e0000000000000
CONST	SEGMENT
__real@43e0000000000000 DQ 043e0000000000000r	; 9.22337e+18
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BF@CAJJEMJD@?6?$FLNULL?5PARAM?5ERROR?$FN?6@
CONST	SEGMENT
??_C@_0BF@CAJJEMJD@?6?$FLNULL?5PARAM?5ERROR?$FN?6@ DB 0aH, '[NULL PARAM E'
	DB	'RROR]', 0aH, 00H				; `string'
CONST	ENDS
_DATA	SEGMENT
?Representation@?1??integerConvert@@9@9 DB '0123456789ABCDEF', 00H ; `integerConvert'::`2'::Representation
	ORG $+7
?Representation@?1??numConvert@@9@9 DB '0123456789ABCDEF', 00H ; `numConvert'::`2'::Representation
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	02aH
	DB	05cH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Geet DD	025053119H
	DD	010a230fH
	DD	070030021H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	0f8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
Geet$rtcName$0 DB 063H
	DB	06fH
	DB	075H
	DB	06eH
	DB	074H
	DB	00H
	ORG $+10
Geet$rtcVarDesc DD 024H
	DD	04H
	DQ	FLAT:Geet$rtcName$0
	ORG $+48
Geet$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:Geet$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GeetCount DD 035051301H
	DD	010e3313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Preent DD 025061901H
	DD	01142319H
	DD	0700d003eH
	DD	0500b600cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$numConvert DD 025051301H
	DD	010e2313H
	DD	070070045H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$strToInt DD 025051301H
	DD	010e2313H
	DD	070070031H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$integerConvert DD 025051601H
	DD	01112316H
	DD	0700a0021H
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pootStr DD 035051d01H
	DD	0118331dH
	DD	070110023H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pootChar DD 035051c01H
	DD	0117331cH
	DD	07010001fH
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$strLenSafe DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	c2 00 00	 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tPreent.c
;	COMDAT Geet
_TEXT	SEGMENT
count$ = 4
__$ArrayPad$ = 216
Geet	PROC						; COMDAT

; 283  : {

$LN3:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00014	b9 0a 00 00 00	 mov	 ecx, 10
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00027	48 33 c5	 xor	 rax, rbp
  0002a	48 89 85 d8 00
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__386B16A1_tPreent@c
  00038	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 284  : 	unsigned int count;
; 285  : 	return GeetCount(&count);

  0003d	48 8d 4d 04	 lea	 rcx, QWORD PTR count$[rbp]
  00041	e8 00 00 00 00	 call	 GeetCount

; 286  : }

  00046	48 8b f8	 mov	 rdi, rax
  00049	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Geet$rtcFrameData
  00054	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00059	48 8b c7	 mov	 rax, rdi
  0005c	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00063	48 33 cd	 xor	 rcx, rbp
  00066	e8 00 00 00 00	 call	 __security_check_cookie
  0006b	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00072	5f		 pop	 rdi
  00073	5d		 pop	 rbp
  00074	c3		 ret	 0
Geet	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tPreent.c
;	COMDAT GeetCount
_TEXT	SEGMENT
count$ = 224
GeetCount PROC						; COMDAT

; 274  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0000e	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__386B16A1_tPreent@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 275  : 	ReadConsoleA(GetStdHandle(STD_INPUT_HANDLE), PREENT_BUFFER, MAX_CONSOLE_BUFFER, count, NULL);

  0001f	b9 f6 ff ff ff	 mov	 ecx, -10		; fffffff6H
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle
  0002a	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00033	4c 8b 8d e0 00
	00 00		 mov	 r9, QWORD PTR count$[rbp]
  0003a	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PREENT_BUFFER
  00047	48 8b c8	 mov	 rcx, rax
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReadConsoleA

; 276  : 
; 277  : 	return PREENT_BUFFER;

  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PREENT_BUFFER

; 278  : 	//*count = *count <= 1 ? 0 : *count - 1;
; 279  : 	//PREENT_BUFFER[*count - 1] = '\0';
; 280  : }

  00057	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0005e	5f		 pop	 rdi
  0005f	5d		 pop	 rbp
  00060	c3		 ret	 0
GeetCount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tPreent.c
;	COMDAT Preent
_TEXT	SEGMENT
startIndex$ = 4
workingIndex$ = 40
ptr$ = 72
output$ = 104
written$ = 132
i$1 = 164
$T2 = 392
$T3 = 432
tv132 = 452
string$ = 496
head$ = 504
Preent	PROC						; COMDAT

; 209  : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	48 81 ec f0 01
	00 00		 sub	 rsp, 496		; 000001f0H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__386B16A1_tPreent@c
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 210  : 	unsigned int startIndex = 0;

  00025	c7 45 04 00 00
	00 00		 mov	 DWORD PTR startIndex$[rbp], 0

; 211  : 	char* workingIndex = PREENT_BUFFER;

  0002c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PREENT_BUFFER
  00033	48 89 45 28	 mov	 QWORD PTR workingIndex$[rbp], rax

; 212  : 
; 213  : 	void* ptr = head;

  00037	48 8b 85 f8 01
	00 00		 mov	 rax, QWORD PTR head$[rbp]
  0003e	48 89 45 48	 mov	 QWORD PTR ptr$[rbp], rax

; 214  : 
; 215  : 	HANDLE output = GetStdHandle(STD_OUTPUT_HANDLE);

  00042	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle
  0004d	48 89 45 68	 mov	 QWORD PTR output$[rbp], rax

; 216  : 	DWORD written = 0;

  00051	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR written$[rbp], 0

; 217  : 
; 218  : 	for (int i = 0; i < MAX_CONSOLE_BUFFER; i++)

  0005b	c7 85 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR i$1[rbp], 0
  00065	eb 0e		 jmp	 SHORT $LN4@Preent
$LN2@Preent:
  00067	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR i$1[rbp]
  0006d	ff c0		 inc	 eax
  0006f	89 85 a4 00 00
	00		 mov	 DWORD PTR i$1[rbp], eax
$LN4@Preent:
  00075	83 bd a4 00 00
	00 40		 cmp	 DWORD PTR i$1[rbp], 64	; 00000040H
  0007c	0f 8d 13 02 00
	00		 jge	 $LN3@Preent

; 219  : 	{
; 220  : 		PREENT_BUFFER[i] = string[i];

  00082	48 63 85 a4 00
	00 00		 movsxd	 rax, DWORD PTR i$1[rbp]
  00089	48 63 8d a4 00
	00 00		 movsxd	 rcx, DWORD PTR i$1[rbp]
  00090	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PREENT_BUFFER
  00097	4c 8b 85 f0 01
	00 00		 mov	 r8, QWORD PTR string$[rbp]
  0009e	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  000a3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 221  : 
; 222  : 		if (string[i] == '\0')

  000a6	48 63 85 a4 00
	00 00		 movsxd	 rax, DWORD PTR i$1[rbp]
  000ad	48 8b 8d f0 01
	00 00		 mov	 rcx, QWORD PTR string$[rbp]
  000b4	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000b8	85 c0		 test	 eax, eax
  000ba	75 1b		 jne	 SHORT $LN7@Preent

; 223  : 		{
; 224  : 			pootStr(workingIndex, output, written);

  000bc	44 8b 85 84 00
	00 00		 mov	 r8d, DWORD PTR written$[rbp]
  000c3	48 8b 55 68	 mov	 rdx, QWORD PTR output$[rbp]
  000c7	48 8b 4d 28	 mov	 rcx, QWORD PTR workingIndex$[rbp]
  000cb	e8 00 00 00 00	 call	 pootStr

; 225  : 			return NULL;

  000d0	33 c0		 xor	 eax, eax
  000d2	e9 d4 01 00 00	 jmp	 $LN1@Preent
$LN7@Preent:

; 226  : 		}
; 227  : 
; 228  : 		if (string[i] == '%')

  000d7	48 63 85 a4 00
	00 00		 movsxd	 rax, DWORD PTR i$1[rbp]
  000de	48 8b 8d f0 01
	00 00		 mov	 rcx, QWORD PTR string$[rbp]
  000e5	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000e9	83 f8 25	 cmp	 eax, 37			; 00000025H
  000ec	0f 85 9e 01 00
	00		 jne	 $LN8@Preent

; 229  : 		{
; 230  : 			PREENT_BUFFER[i] = '\0';

  000f2	48 63 85 a4 00
	00 00		 movsxd	 rax, DWORD PTR i$1[rbp]
  000f9	48 89 85 88 01
	00 00		 mov	 QWORD PTR $T2[rbp], rax
  00100	48 83 bd 88 01
	00 00 40	 cmp	 QWORD PTR $T2[rbp], 64	; 00000040H
  00108	73 02		 jae	 SHORT $LN24@Preent
  0010a	eb 05		 jmp	 SHORT $LN25@Preent
$LN24@Preent:
  0010c	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN25@Preent:
  00111	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PREENT_BUFFER
  00118	48 8b 8d 88 01
	00 00		 mov	 rcx, QWORD PTR $T2[rbp]
  0011f	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 231  : 			pootStr(workingIndex, output, written);

  00123	44 8b 85 84 00
	00 00		 mov	 r8d, DWORD PTR written$[rbp]
  0012a	48 8b 55 68	 mov	 rdx, QWORD PTR output$[rbp]
  0012e	48 8b 4d 28	 mov	 rcx, QWORD PTR workingIndex$[rbp]
  00132	e8 00 00 00 00	 call	 pootStr

; 232  : 			workingIndex = &PREENT_BUFFER[i + 1];

  00137	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR i$1[rbp]
  0013d	ff c0		 inc	 eax
  0013f	48 98		 cdqe
  00141	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PREENT_BUFFER
  00148	48 03 c8	 add	 rcx, rax
  0014b	48 8b c1	 mov	 rax, rcx
  0014e	48 89 45 28	 mov	 QWORD PTR workingIndex$[rbp], rax

; 233  : 
; 234  : 			switch (head[0]._type)

  00152	b8 10 00 00 00	 mov	 eax, 16
  00157	48 6b c0 00	 imul	 rax, rax, 0
  0015b	48 8b 8d f8 01
	00 00		 mov	 rcx, QWORD PTR head$[rbp]
  00162	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00165	89 85 c4 01 00
	00		 mov	 DWORD PTR tv132[rbp], eax
  0016b	8b 85 c4 01 00
	00		 mov	 eax, DWORD PTR tv132[rbp]
  00171	83 c0 02	 add	 eax, 2
  00174	89 85 c4 01 00
	00		 mov	 DWORD PTR tv132[rbp], eax
  0017a	83 bd c4 01 00
	00 22		 cmp	 DWORD PTR tv132[rbp], 34 ; 00000022H
  00181	0f 87 09 01 00
	00		 ja	 $LN22@Preent
  00187	48 63 85 c4 01
	00 00		 movsxd	 rax, DWORD PTR tv132[rbp]
  0018e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00195	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN26@Preent[rcx+rax]
  0019d	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN27@Preent[rcx+rax*4]
  001a4	48 03 c1	 add	 rax, rcx
  001a7	ff e0		 jmp	 rax
$LN9@Preent:

; 235  : 			{
; 236  : 			case __c:
; 237  : 				pootChar(*((char*)(head[0]._ptr)), output, written);

  001a9	b8 10 00 00 00	 mov	 eax, 16
  001ae	48 6b c0 00	 imul	 rax, rax, 0
  001b2	48 8b 8d f8 01
	00 00		 mov	 rcx, QWORD PTR head$[rbp]
  001b9	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  001be	44 8b 85 84 00
	00 00		 mov	 r8d, DWORD PTR written$[rbp]
  001c5	48 8b 55 68	 mov	 rdx, QWORD PTR output$[rbp]
  001c9	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  001cc	e8 00 00 00 00	 call	 pootChar

; 238  : 				head++;

  001d1	48 8b 85 f8 01
	00 00		 mov	 rax, QWORD PTR head$[rbp]
  001d8	48 83 c0 10	 add	 rax, 16
  001dc	48 89 85 f8 01
	00 00		 mov	 QWORD PTR head$[rbp], rax

; 239  : 				break;

  001e3	e9 a8 00 00 00	 jmp	 $LN5@Preent
$LN10@Preent:

; 240  : 
; 241  : 			case __s:
; 242  : 				pootStr((char*)(head[0]._ptr), output, written);

  001e8	b8 10 00 00 00	 mov	 eax, 16
  001ed	48 6b c0 00	 imul	 rax, rax, 0
  001f1	44 8b 85 84 00
	00 00		 mov	 r8d, DWORD PTR written$[rbp]
  001f8	48 8b 55 68	 mov	 rdx, QWORD PTR output$[rbp]
  001fc	48 8b 8d f8 01
	00 00		 mov	 rcx, QWORD PTR head$[rbp]
  00203	48 8b 4c 01 08	 mov	 rcx, QWORD PTR [rcx+rax+8]
  00208	e8 00 00 00 00	 call	 pootStr

; 243  : 				head++;

  0020d	48 8b 85 f8 01
	00 00		 mov	 rax, QWORD PTR head$[rbp]
  00214	48 83 c0 10	 add	 rax, 16
  00218	48 89 85 f8 01
	00 00		 mov	 QWORD PTR head$[rbp], rax

; 244  : 				break;

  0021f	eb 6f		 jmp	 SHORT $LN5@Preent
$LN11@Preent:
$LN12@Preent:
$LN13@Preent:
$LN14@Preent:
$LN15@Preent:
$LN16@Preent:
$LN17@Preent:
$LN18@Preent:
$LN19@Preent:
$LN20@Preent:

; 245  : 
; 246  : 			case __I:
; 247  : 			case __L:
; 248  : 			case __x:
; 249  : 			case __l:
; 250  : 			case __O:
; 251  : 			case __h:
; 252  : 			case __i:
; 253  : 			case __o:
; 254  : 			case __f:
; 255  : 			case __d:
; 256  : 				pootStr(numConvert(head[0]), output, written);

  00221	b8 10 00 00 00	 mov	 eax, 16
  00226	48 6b c0 00	 imul	 rax, rax, 0
  0022a	48 8d 8d b0 01
	00 00		 lea	 rcx, QWORD PTR $T3[rbp]
  00231	48 8b 95 f8 01
	00 00		 mov	 rdx, QWORD PTR head$[rbp]
  00238	48 8b f9	 mov	 rdi, rcx
  0023b	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  0023f	b9 10 00 00 00	 mov	 ecx, 16
  00244	f3 a4		 rep movsb
  00246	48 8d 8d b0 01
	00 00		 lea	 rcx, QWORD PTR $T3[rbp]
  0024d	e8 00 00 00 00	 call	 numConvert
  00252	44 8b 85 84 00
	00 00		 mov	 r8d, DWORD PTR written$[rbp]
  00259	48 8b 55 68	 mov	 rdx, QWORD PTR output$[rbp]
  0025d	48 8b c8	 mov	 rcx, rax
  00260	e8 00 00 00 00	 call	 pootStr

; 257  : 				head++;

  00265	48 8b 85 f8 01
	00 00		 mov	 rax, QWORD PTR head$[rbp]
  0026c	48 83 c0 10	 add	 rax, 16
  00270	48 89 85 f8 01
	00 00		 mov	 QWORD PTR head$[rbp], rax

; 258  : 				break;

  00277	eb 17		 jmp	 SHORT $LN5@Preent
$LN21@Preent:

; 259  : 
; 260  : 			case NONE:
; 261  : 				pootStr("\n[NULL PARAM ERROR]\n", output, written);

  00279	44 8b 85 84 00
	00 00		 mov	 r8d, DWORD PTR written$[rbp]
  00280	48 8b 55 68	 mov	 rdx, QWORD PTR output$[rbp]
  00284	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@CAJJEMJD@?6?$FLNULL?5PARAM?5ERROR?$FN?6@
  0028b	e8 00 00 00 00	 call	 pootStr
$LN22@Preent:
$LN5@Preent:
$LN8@Preent:

; 262  : 				break;
; 263  : 
; 264  : 			default:
; 265  : 				break;
; 266  : 			}
; 267  : 		}
; 268  : 	}

  00290	e9 d2 fd ff ff	 jmp	 $LN2@Preent
$LN3@Preent:

; 269  : 
; 270  : 	return &(string[MAX_CONSOLE_BUFFER]);

  00295	b8 01 00 00 00	 mov	 eax, 1
  0029a	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  0029e	48 8b 8d f0 01
	00 00		 mov	 rcx, QWORD PTR string$[rbp]
  002a5	48 03 c8	 add	 rcx, rax
  002a8	48 8b c1	 mov	 rax, rcx
$LN1@Preent:
$LN23@Preent:

; 271  : }

  002ab	48 8d a5 d0 01
	00 00		 lea	 rsp, QWORD PTR [rbp+464]
  002b2	5f		 pop	 rdi
  002b3	5e		 pop	 rsi
  002b4	5d		 pop	 rbp
  002b5	c3		 ret	 0
  002b6	66 90		 npad	 2
$LN27@Preent:
  002b8	00 00 00 00	 DD	 $LN21@Preent
  002bc	00 00 00 00	 DD	 $LN9@Preent
  002c0	00 00 00 00	 DD	 $LN10@Preent
  002c4	00 00 00 00	 DD	 $LN12@Preent
  002c8	00 00 00 00	 DD	 $LN11@Preent
  002cc	00 00 00 00	 DD	 $LN13@Preent
  002d0	00 00 00 00	 DD	 $LN14@Preent
  002d4	00 00 00 00	 DD	 $LN15@Preent
  002d8	00 00 00 00	 DD	 $LN16@Preent
  002dc	00 00 00 00	 DD	 $LN17@Preent
  002e0	00 00 00 00	 DD	 $LN18@Preent
  002e4	00 00 00 00	 DD	 $LN19@Preent
  002e8	00 00 00 00	 DD	 $LN20@Preent
  002ec	00 00 00 00	 DD	 $LN22@Preent
$LN26@Preent:
  002f0	00		 DB	 0
  002f1	0d		 DB	 13
  002f2	0d		 DB	 13
  002f3	0d		 DB	 13
  002f4	0d		 DB	 13
  002f5	0d		 DB	 13
  002f6	0d		 DB	 13
  002f7	0d		 DB	 13
  002f8	0d		 DB	 13
  002f9	0d		 DB	 13
  002fa	0d		 DB	 13
  002fb	0d		 DB	 13
  002fc	0d		 DB	 13
  002fd	0d		 DB	 13
  002fe	0d		 DB	 13
  002ff	0d		 DB	 13
  00300	0d		 DB	 13
  00301	0d		 DB	 13
  00302	0d		 DB	 13
  00303	0d		 DB	 13
  00304	0d		 DB	 13
  00305	0d		 DB	 13
  00306	0d		 DB	 13
  00307	01		 DB	 1
  00308	02		 DB	 2
  00309	03		 DB	 3
  0030a	04		 DB	 4
  0030b	05		 DB	 5
  0030c	06		 DB	 6
  0030d	07		 DB	 7
  0030e	08		 DB	 8
  0030f	09		 DB	 9
  00310	0a		 DB	 10
  00311	0b		 DB	 11
  00312	0c		 DB	 12
Preent	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tPreent.c
;	COMDAT numConvert
_TEXT	SEGMENT
ptr$ = 8
isPositive$ = 68
isInt$ = 100
intCheck$ = 132
longCheck$ = 168
fVal$ = 200
iVal$ = 232
fRem$ = 264
base$ = 292
tv134 = 500
tv132 = 500
tv79 = 500
tv74 = 500
tv71 = 500
tv67 = 500
tv163 = 504
tv159 = 504
tv154 = 504
tv150 = 504
tv82 = 504
preem$ = 544
numConvert PROC						; COMDAT

; 102  : {

$LN46:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 28 02
	00 00		 sub	 rsp, 552		; 00000228H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__386B16A1_tPreent@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 103  : 	static char Representation[] = "0123456789ABCDEF";
; 104  : 	static char Buffer[MAX_NUM_BUFFER];
; 105  : 
; 106  : 	char* ptr = &Buffer[MAX_NUM_BUFFER - 1];

  0001f	b8 01 00 00 00	 mov	 eax, 1
  00024	48 6b c0 31	 imul	 rax, rax, 49		; 00000031H
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Buffer@?1??numConvert@@9@9
  0002f	48 03 c8	 add	 rcx, rax
  00032	48 8b c1	 mov	 rax, rcx
  00035	48 89 45 08	 mov	 QWORD PTR ptr$[rbp], rax

; 107  : 	*ptr = '\0';

  00039	48 8b 45 08	 mov	 rax, QWORD PTR ptr$[rbp]
  0003d	c6 00 00	 mov	 BYTE PTR [rax], 0

; 108  : 
; 109  : 	char next;
; 110  : 	int isPositive = 1;

  00040	c7 45 44 01 00
	00 00		 mov	 DWORD PTR isPositive$[rbp], 1

; 111  : 	int isInt = 0;

  00047	c7 45 64 00 00
	00 00		 mov	 DWORD PTR isInt$[rbp], 0

; 112  : 
; 113  : 	int intCheck;
; 114  : 	long long longCheck;
; 115  : 
; 116  : 	double fVal = 0;

  0004e	0f 57 c0	 xorps	 xmm0, xmm0
  00051	f2 0f 11 85 c8
	00 00 00	 movsd	 QWORD PTR fVal$[rbp], xmm0

; 117  : 	unsigned long long iVal = 0;

  00059	48 c7 85 e8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR iVal$[rbp], 0

; 118  : 	unsigned long long fRem = 0;

  00064	48 c7 85 08 01
	00 00 00 00 00
	00		 mov	 QWORD PTR fRem$[rbp], 0

; 119  : 	unsigned int base = 0;

  0006f	c7 85 24 01 00
	00 00 00 00 00	 mov	 DWORD PTR base$[rbp], 0

; 120  : 
; 121  : 	switch (preem._type)

  00079	48 8b 85 20 02
	00 00		 mov	 rax, QWORD PTR preem$[rbp]
  00080	8b 00		 mov	 eax, DWORD PTR [rax]
  00082	89 85 f4 01 00
	00		 mov	 DWORD PTR tv67[rbp], eax
  00088	8b 85 f4 01 00
	00		 mov	 eax, DWORD PTR tv67[rbp]
  0008e	83 e8 17	 sub	 eax, 23
  00091	89 85 f4 01 00
	00		 mov	 DWORD PTR tv67[rbp], eax
  00097	83 bd f4 01 00
	00 09		 cmp	 DWORD PTR tv67[rbp], 9
  0009e	0f 87 dc 02 00
	00		 ja	 $LN2@numConvert
  000a4	48 63 85 f4 01
	00 00		 movsxd	 rax, DWORD PTR tv67[rbp]
  000ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000b2	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN45@numConvert[rcx+rax*4]
  000b9	48 03 c1	 add	 rax, rcx
  000bc	ff e0		 jmp	 rax
$LN13@numConvert:

; 122  : 	{
; 123  : 	case __I:
; 124  : 		intCheck = *((int*)(preem._ptr));

  000be	48 8b 85 20 02
	00 00		 mov	 rax, QWORD PTR preem$[rbp]
  000c5	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000c9	8b 00		 mov	 eax, DWORD PTR [rax]
  000cb	89 85 84 00 00
	00		 mov	 DWORD PTR intCheck$[rbp], eax

; 125  : 		isPositive = intCheck >= 0;

  000d1	83 bd 84 00 00
	00 00		 cmp	 DWORD PTR intCheck$[rbp], 0
  000d8	7c 0c		 jl	 SHORT $LN27@numConvert
  000da	c7 85 f4 01 00
	00 01 00 00 00	 mov	 DWORD PTR tv71[rbp], 1
  000e4	eb 0a		 jmp	 SHORT $LN28@numConvert
$LN27@numConvert:
  000e6	c7 85 f4 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv71[rbp], 0
$LN28@numConvert:
  000f0	8b 85 f4 01 00
	00		 mov	 eax, DWORD PTR tv71[rbp]
  000f6	89 45 44	 mov	 DWORD PTR isPositive$[rbp], eax

; 126  : 		iVal = isPositive ? intCheck : -intCheck;

  000f9	83 7d 44 00	 cmp	 DWORD PTR isPositive$[rbp], 0
  000fd	74 0e		 je	 SHORT $LN29@numConvert
  000ff	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR intCheck$[rbp]
  00105	89 85 f4 01 00
	00		 mov	 DWORD PTR tv74[rbp], eax
  0010b	eb 0e		 jmp	 SHORT $LN30@numConvert
$LN29@numConvert:
  0010d	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR intCheck$[rbp]
  00113	f7 d8		 neg	 eax
  00115	89 85 f4 01 00
	00		 mov	 DWORD PTR tv74[rbp], eax
$LN30@numConvert:
  0011b	48 63 85 f4 01
	00 00		 movsxd	 rax, DWORD PTR tv74[rbp]
  00122	48 89 85 e8 00
	00 00		 mov	 QWORD PTR iVal$[rbp], rax

; 127  : 		base = 10;

  00129	c7 85 24 01 00
	00 0a 00 00 00	 mov	 DWORD PTR base$[rbp], 10

; 128  : 		goto IsInt;

  00133	e9 07 01 00 00	 jmp	 $IsInt$47
$LN14@numConvert:

; 129  : 	case __L:
; 130  : 		longCheck = *((long long*)(preem._ptr));

  00138	48 8b 85 20 02
	00 00		 mov	 rax, QWORD PTR preem$[rbp]
  0013f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00143	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00146	48 89 85 a8 00
	00 00		 mov	 QWORD PTR longCheck$[rbp], rax

; 131  : 		isPositive = longCheck >= 0;

  0014d	48 83 bd a8 00
	00 00 00	 cmp	 QWORD PTR longCheck$[rbp], 0
  00155	7c 0c		 jl	 SHORT $LN31@numConvert
  00157	c7 85 f4 01 00
	00 01 00 00 00	 mov	 DWORD PTR tv79[rbp], 1
  00161	eb 0a		 jmp	 SHORT $LN32@numConvert
$LN31@numConvert:
  00163	c7 85 f4 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv79[rbp], 0
$LN32@numConvert:
  0016d	8b 85 f4 01 00
	00		 mov	 eax, DWORD PTR tv79[rbp]
  00173	89 45 44	 mov	 DWORD PTR isPositive$[rbp], eax

; 132  : 		iVal = isPositive ? longCheck : -longCheck;

  00176	83 7d 44 00	 cmp	 DWORD PTR isPositive$[rbp], 0
  0017a	74 10		 je	 SHORT $LN33@numConvert
  0017c	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR longCheck$[rbp]
  00183	48 89 85 f8 01
	00 00		 mov	 QWORD PTR tv82[rbp], rax
  0018a	eb 11		 jmp	 SHORT $LN34@numConvert
$LN33@numConvert:
  0018c	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR longCheck$[rbp]
  00193	48 f7 d8	 neg	 rax
  00196	48 89 85 f8 01
	00 00		 mov	 QWORD PTR tv82[rbp], rax
$LN34@numConvert:
  0019d	48 8b 85 f8 01
	00 00		 mov	 rax, QWORD PTR tv82[rbp]
  001a4	48 89 85 e8 00
	00 00		 mov	 QWORD PTR iVal$[rbp], rax

; 133  : 		base = 10;

  001ab	c7 85 24 01 00
	00 0a 00 00 00	 mov	 DWORD PTR base$[rbp], 10

; 134  : 		goto IsInt;

  001b5	e9 85 00 00 00	 jmp	 $IsInt$47
$LN15@numConvert:

; 135  : 	case __x:
; 136  : 		base += 6;

  001ba	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR base$[rbp]
  001c0	83 c0 06	 add	 eax, 6
  001c3	89 85 24 01 00
	00		 mov	 DWORD PTR base$[rbp], eax
$LN16@numConvert:

; 137  : 	case __l:
; 138  : 		base += 2;

  001c9	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR base$[rbp]
  001cf	83 c0 02	 add	 eax, 2
  001d2	89 85 24 01 00
	00		 mov	 DWORD PTR base$[rbp], eax
$LN17@numConvert:

; 139  : 	case __O:
; 140  : 		base += 8;

  001d8	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR base$[rbp]
  001de	83 c0 08	 add	 eax, 8
  001e1	89 85 24 01 00
	00		 mov	 DWORD PTR base$[rbp], eax

; 141  : 		iVal = *((unsigned long long*)(preem._ptr));

  001e7	48 8b 85 20 02
	00 00		 mov	 rax, QWORD PTR preem$[rbp]
  001ee	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001f2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001f5	48 89 85 e8 00
	00 00		 mov	 QWORD PTR iVal$[rbp], rax

; 142  : 		goto IsInt;

  001fc	eb 41		 jmp	 SHORT $IsInt$47
$LN18@numConvert:

; 143  : 	case __h:
; 144  : 		base += 6;

  001fe	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR base$[rbp]
  00204	83 c0 06	 add	 eax, 6
  00207	89 85 24 01 00
	00		 mov	 DWORD PTR base$[rbp], eax
$LN19@numConvert:

; 145  : 	case __i:
; 146  : 		base += 2;

  0020d	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR base$[rbp]
  00213	83 c0 02	 add	 eax, 2
  00216	89 85 24 01 00
	00		 mov	 DWORD PTR base$[rbp], eax
$LN20@numConvert:

; 147  : 	case __o:
; 148  : 		base += 8;

  0021c	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR base$[rbp]
  00222	83 c0 08	 add	 eax, 8
  00225	89 85 24 01 00
	00		 mov	 DWORD PTR base$[rbp], eax

; 149  : 		iVal = *((unsigned int*)(preem._ptr));

  0022b	48 8b 85 20 02
	00 00		 mov	 rax, QWORD PTR preem$[rbp]
  00232	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00236	8b 00		 mov	 eax, DWORD PTR [rax]
  00238	48 89 85 e8 00
	00 00		 mov	 QWORD PTR iVal$[rbp], rax
$IsInt$47:

; 150  : 	IsInt:
; 151  : 		isInt = 1;

  0023f	c7 45 64 01 00
	00 00		 mov	 DWORD PTR isInt$[rbp], 1

; 152  : 		break;

  00246	e9 35 01 00 00	 jmp	 $LN2@numConvert
$LN21@numConvert:

; 153  : 
; 154  : 	case __f:
; 155  : 		fVal = *((float*)(preem._ptr));

  0024b	48 8b 85 20 02
	00 00		 mov	 rax, QWORD PTR preem$[rbp]
  00252	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00256	f3 0f 5a 00	 cvtss2sd xmm0, DWORD PTR [rax]
  0025a	f2 0f 11 85 c8
	00 00 00	 movsd	 QWORD PTR fVal$[rbp], xmm0

; 156  : 		goto IsFloat;

  00262	eb 17		 jmp	 SHORT $IsFloat$48
$LN22@numConvert:

; 157  : 	case __d:
; 158  : 		fVal = *((double*)(preem._ptr));

  00264	48 8b 85 20 02
	00 00		 mov	 rax, QWORD PTR preem$[rbp]
  0026b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0026f	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [rax]
  00273	f2 0f 11 85 c8
	00 00 00	 movsd	 QWORD PTR fVal$[rbp], xmm0
$IsFloat$48:

; 159  : 	IsFloat:
; 160  : 		isPositive = fVal >= 0;

  0027b	f2 0f 10 85 c8
	00 00 00	 movsd	 xmm0, QWORD PTR fVal$[rbp]
  00283	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  0028b	72 0c		 jb	 SHORT $LN35@numConvert
  0028d	c7 85 f4 01 00
	00 01 00 00 00	 mov	 DWORD PTR tv132[rbp], 1
  00297	eb 0a		 jmp	 SHORT $LN36@numConvert
$LN35@numConvert:
  00299	c7 85 f4 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv132[rbp], 0
$LN36@numConvert:
  002a3	8b 85 f4 01 00
	00		 mov	 eax, DWORD PTR tv132[rbp]
  002a9	89 45 44	 mov	 DWORD PTR isPositive$[rbp], eax

; 161  : 		fVal *= isPositive ? 1 : -1;

  002ac	83 7d 44 00	 cmp	 DWORD PTR isPositive$[rbp], 0
  002b0	74 0c		 je	 SHORT $LN37@numConvert
  002b2	c7 85 f4 01 00
	00 01 00 00 00	 mov	 DWORD PTR tv134[rbp], 1
  002bc	eb 0a		 jmp	 SHORT $LN38@numConvert
$LN37@numConvert:
  002be	c7 85 f4 01 00
	00 ff ff ff ff	 mov	 DWORD PTR tv134[rbp], -1
$LN38@numConvert:
  002c8	f2 0f 2a 85 f4
	01 00 00	 cvtsi2sd xmm0, DWORD PTR tv134[rbp]
  002d0	f2 0f 10 8d c8
	00 00 00	 movsd	 xmm1, QWORD PTR fVal$[rbp]
  002d8	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  002dc	0f 28 c1	 movaps	 xmm0, xmm1
  002df	f2 0f 11 85 c8
	00 00 00	 movsd	 QWORD PTR fVal$[rbp], xmm0

; 162  : 		iVal = fVal;

  002e7	33 c0		 xor	 eax, eax
  002e9	f2 0f 10 85 c8
	00 00 00	 movsd	 xmm0, QWORD PTR fVal$[rbp]
  002f1	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@43e0000000000000
  002f9	72 1f		 jb	 SHORT $LN44@numConvert
  002fb	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@43e0000000000000
  00303	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@43e0000000000000
  0030b	73 0d		 jae	 SHORT $LN44@numConvert
  0030d	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00317	48 03 c1	 add	 rax, rcx
$LN44@numConvert:
  0031a	f2 48 0f 2c c8	 cvttsd2si rcx, xmm0
  0031f	48 03 c8	 add	 rcx, rax
  00322	48 8b c1	 mov	 rax, rcx
  00325	48 89 85 e8 00
	00 00		 mov	 QWORD PTR iVal$[rbp], rax

; 163  : 		fVal -= iVal;

  0032c	48 8b 85 e8 00
	00 00		 mov	 rax, QWORD PTR iVal$[rbp]
  00333	48 85 c0	 test	 rax, rax
  00336	7c 07		 jl	 SHORT $LN42@numConvert
  00338	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  0033d	eb 19		 jmp	 SHORT $LN43@numConvert
$LN42@numConvert:
  0033f	48 8b c8	 mov	 rcx, rax
  00342	48 d1 e9	 shr	 rcx, 1
  00345	48 83 e0 01	 and	 rax, 1
  00349	48 0b c8	 or	 rcx, rax
  0034c	f2 48 0f 2a c9	 cvtsi2sd xmm1, rcx
  00351	f2 0f 58 c9	 addsd	 xmm1, xmm1
  00355	0f 28 c1	 movaps	 xmm0, xmm1
$LN43@numConvert:
  00358	f2 0f 10 8d c8
	00 00 00	 movsd	 xmm1, QWORD PTR fVal$[rbp]
  00360	f2 0f 5c c8	 subsd	 xmm1, xmm0
  00364	0f 28 c1	 movaps	 xmm0, xmm1
  00367	f2 0f 11 85 c8
	00 00 00	 movsd	 QWORD PTR fVal$[rbp], xmm0

; 164  : 		base = 10;

  0036f	c7 85 24 01 00
	00 0a 00 00 00	 mov	 DWORD PTR base$[rbp], 10

; 165  : 		isInt = 0;

  00379	c7 45 64 00 00
	00 00		 mov	 DWORD PTR isInt$[rbp], 0
$LN2@numConvert:

; 166  : 	}
; 167  : 
; 168  : 	if (!isInt)

  00380	83 7d 64 00	 cmp	 DWORD PTR isInt$[rbp], 0
  00384	0f 85 3e 01 00
	00		 jne	 $LN23@numConvert

; 169  : 	{
; 170  : 		if (fVal > 0)

  0038a	f2 0f 10 85 c8
	00 00 00	 movsd	 xmm0, QWORD PTR fVal$[rbp]
  00392	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  0039a	0f 86 28 01 00
	00		 jbe	 $LN24@numConvert
$LN6@numConvert:

; 171  : 		{
; 172  : 			do
; 173  : 			{
; 174  : 				fVal *= 10;

  003a0	f2 0f 10 85 c8
	00 00 00	 movsd	 xmm0, QWORD PTR fVal$[rbp]
  003a8	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4024000000000000
  003b0	f2 0f 11 85 c8
	00 00 00	 movsd	 QWORD PTR fVal$[rbp], xmm0

; 175  : 				fRem = fVal;

  003b8	33 c0		 xor	 eax, eax
  003ba	f2 0f 10 85 c8
	00 00 00	 movsd	 xmm0, QWORD PTR fVal$[rbp]
  003c2	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@43e0000000000000
  003ca	72 1f		 jb	 SHORT $LN41@numConvert
  003cc	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@43e0000000000000
  003d4	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@43e0000000000000
  003dc	73 0d		 jae	 SHORT $LN41@numConvert
  003de	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  003e8	48 03 c1	 add	 rax, rcx
$LN41@numConvert:
  003eb	f2 48 0f 2c c8	 cvttsd2si rcx, xmm0
  003f0	48 03 c8	 add	 rcx, rax
  003f3	48 8b c1	 mov	 rax, rcx
  003f6	48 89 85 08 01
	00 00		 mov	 QWORD PTR fRem$[rbp], rax

; 176  : 			} while (fVal - (double)fRem > 0);

  003fd	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR fRem$[rbp]
  00404	48 85 c0	 test	 rax, rax
  00407	7c 07		 jl	 SHORT $LN39@numConvert
  00409	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  0040e	eb 19		 jmp	 SHORT $LN40@numConvert
$LN39@numConvert:
  00410	48 8b c8	 mov	 rcx, rax
  00413	48 d1 e9	 shr	 rcx, 1
  00416	48 83 e0 01	 and	 rax, 1
  0041a	48 0b c8	 or	 rcx, rax
  0041d	f2 48 0f 2a c9	 cvtsi2sd xmm1, rcx
  00422	f2 0f 58 c9	 addsd	 xmm1, xmm1
  00426	0f 28 c1	 movaps	 xmm0, xmm1
$LN40@numConvert:
  00429	f2 0f 10 8d c8
	00 00 00	 movsd	 xmm1, QWORD PTR fVal$[rbp]
  00431	f2 0f 5c c8	 subsd	 xmm1, xmm0
  00435	0f 28 c1	 movaps	 xmm0, xmm1
  00438	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  00440	0f 87 5a ff ff
	ff		 ja	 $LN6@numConvert
$LN9@numConvert:

; 177  : 
; 178  : 			do
; 179  : 			{
; 180  : 				ptr -= 1;

  00446	48 8b 45 08	 mov	 rax, QWORD PTR ptr$[rbp]
  0044a	48 ff c8	 dec	 rax
  0044d	48 89 45 08	 mov	 QWORD PTR ptr$[rbp], rax

; 181  : 				*ptr = Representation[fRem % base];

  00451	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR base$[rbp]
  00457	48 89 85 f8 01
	00 00		 mov	 QWORD PTR tv150[rbp], rax
  0045e	33 d2		 xor	 edx, edx
  00460	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR fRem$[rbp]
  00467	48 8b 8d f8 01
	00 00		 mov	 rcx, QWORD PTR tv150[rbp]
  0046e	48 f7 f1	 div	 rcx
  00471	48 8b c2	 mov	 rax, rdx
  00474	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Representation@?1??numConvert@@9@9
  0047b	48 8b 55 08	 mov	 rdx, QWORD PTR ptr$[rbp]
  0047f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00483	88 02		 mov	 BYTE PTR [rdx], al

; 182  : 				fRem /= base;

  00485	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR base$[rbp]
  0048b	48 89 85 f8 01
	00 00		 mov	 QWORD PTR tv154[rbp], rax
  00492	33 d2		 xor	 edx, edx
  00494	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR fRem$[rbp]
  0049b	48 8b 8d f8 01
	00 00		 mov	 rcx, QWORD PTR tv154[rbp]
  004a2	48 f7 f1	 div	 rcx
  004a5	48 89 85 08 01
	00 00		 mov	 QWORD PTR fRem$[rbp], rax

; 183  : 
; 184  : 			} while (fRem != 0);

  004ac	48 83 bd 08 01
	00 00 00	 cmp	 QWORD PTR fRem$[rbp], 0
  004b4	75 90		 jne	 SHORT $LN9@numConvert

; 185  : 
; 186  : 			ptr -= 1;

  004b6	48 8b 45 08	 mov	 rax, QWORD PTR ptr$[rbp]
  004ba	48 ff c8	 dec	 rax
  004bd	48 89 45 08	 mov	 QWORD PTR ptr$[rbp], rax

; 187  : 			*ptr = '.';

  004c1	48 8b 45 08	 mov	 rax, QWORD PTR ptr$[rbp]
  004c5	c6 00 2e	 mov	 BYTE PTR [rax], 46	; 0000002eH
$LN24@numConvert:
$LN23@numConvert:
$LN12@numConvert:

; 188  : 		}
; 189  : 	}
; 190  : 
; 191  : 	do
; 192  : 	{
; 193  : 		ptr -= 1;

  004c8	48 8b 45 08	 mov	 rax, QWORD PTR ptr$[rbp]
  004cc	48 ff c8	 dec	 rax
  004cf	48 89 45 08	 mov	 QWORD PTR ptr$[rbp], rax

; 194  : 		*ptr = Representation[iVal % base];

  004d3	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR base$[rbp]
  004d9	48 89 85 f8 01
	00 00		 mov	 QWORD PTR tv159[rbp], rax
  004e0	33 d2		 xor	 edx, edx
  004e2	48 8b 85 e8 00
	00 00		 mov	 rax, QWORD PTR iVal$[rbp]
  004e9	48 8b 8d f8 01
	00 00		 mov	 rcx, QWORD PTR tv159[rbp]
  004f0	48 f7 f1	 div	 rcx
  004f3	48 8b c2	 mov	 rax, rdx
  004f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Representation@?1??numConvert@@9@9
  004fd	48 8b 55 08	 mov	 rdx, QWORD PTR ptr$[rbp]
  00501	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00505	88 02		 mov	 BYTE PTR [rdx], al

; 195  : 		iVal /= base;

  00507	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR base$[rbp]
  0050d	48 89 85 f8 01
	00 00		 mov	 QWORD PTR tv163[rbp], rax
  00514	33 d2		 xor	 edx, edx
  00516	48 8b 85 e8 00
	00 00		 mov	 rax, QWORD PTR iVal$[rbp]
  0051d	48 8b 8d f8 01
	00 00		 mov	 rcx, QWORD PTR tv163[rbp]
  00524	48 f7 f1	 div	 rcx
  00527	48 89 85 e8 00
	00 00		 mov	 QWORD PTR iVal$[rbp], rax

; 196  : 
; 197  : 	} while (iVal != 0);

  0052e	48 83 bd e8 00
	00 00 00	 cmp	 QWORD PTR iVal$[rbp], 0
  00536	75 90		 jne	 SHORT $LN12@numConvert

; 198  : 
; 199  : 	if (!isPositive)

  00538	83 7d 44 00	 cmp	 DWORD PTR isPositive$[rbp], 0
  0053c	75 12		 jne	 SHORT $LN25@numConvert

; 200  : 	{
; 201  : 		ptr -= 1;

  0053e	48 8b 45 08	 mov	 rax, QWORD PTR ptr$[rbp]
  00542	48 ff c8	 dec	 rax
  00545	48 89 45 08	 mov	 QWORD PTR ptr$[rbp], rax

; 202  : 		*ptr = '-';

  00549	48 8b 45 08	 mov	 rax, QWORD PTR ptr$[rbp]
  0054d	c6 00 2d	 mov	 BYTE PTR [rax], 45	; 0000002dH
$LN25@numConvert:

; 203  : 	}
; 204  : 
; 205  : 	return(ptr);

  00550	48 8b 45 08	 mov	 rax, QWORD PTR ptr$[rbp]

; 206  : }

  00554	48 8d a5 08 02
	00 00		 lea	 rsp, QWORD PTR [rbp+520]
  0055b	5f		 pop	 rdi
  0055c	5d		 pop	 rbp
  0055d	c3		 ret	 0
  0055e	66 90		 npad	 2
$LN45@numConvert:
  00560	00 00 00 00	 DD	 $LN14@numConvert
  00564	00 00 00 00	 DD	 $LN13@numConvert
  00568	00 00 00 00	 DD	 $LN15@numConvert
  0056c	00 00 00 00	 DD	 $LN16@numConvert
  00570	00 00 00 00	 DD	 $LN17@numConvert
  00574	00 00 00 00	 DD	 $LN18@numConvert
  00578	00 00 00 00	 DD	 $LN19@numConvert
  0057c	00 00 00 00	 DD	 $LN20@numConvert
  00580	00 00 00 00	 DD	 $LN21@numConvert
  00584	00 00 00 00	 DD	 $LN22@numConvert
numConvert ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tPreent.c
;	COMDAT strToInt
_TEXT	SEGMENT
numStart$ = 4
isNegative$ = 36
output$ = 68
start$ = 100
end$ = 132
tv80 = 340
input$ = 384
strToInt PROC						; COMDAT

; 69   : {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__386B16A1_tPreent@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 70   : 	int numStart = 0;

  0001f	c7 45 04 00 00
	00 00		 mov	 DWORD PTR numStart$[rbp], 0

; 71   : 	int isNegative = 0;

  00026	c7 45 24 00 00
	00 00		 mov	 DWORD PTR isNegative$[rbp], 0

; 72   : 	int output = 0;

  0002d	c7 45 44 00 00
	00 00		 mov	 DWORD PTR output$[rbp], 0

; 73   : 
; 74   : 	char start = '0';

  00034	c6 45 64 30	 mov	 BYTE PTR start$[rbp], 48 ; 00000030H

; 75   : 	char end = '9';

  00038	c6 85 84 00 00
	00 39		 mov	 BYTE PTR end$[rbp], 57	; 00000039H
$LN2@strToInt:

; 76   : 
; 77   : 	while (*input != '\0')

  0003f	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR input$[rbp]
  00046	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00049	85 c0		 test	 eax, eax
  0004b	74 7c		 je	 SHORT $LN3@strToInt

; 78   : 	{
; 79   : 		if (!numStart && *input == '-')

  0004d	83 7d 04 00	 cmp	 DWORD PTR numStart$[rbp], 0
  00051	75 16		 jne	 SHORT $LN4@strToInt
  00053	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR input$[rbp]
  0005a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0005d	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00060	75 07		 jne	 SHORT $LN4@strToInt

; 80   : 			isNegative = 1;

  00062	c7 45 24 01 00
	00 00		 mov	 DWORD PTR isNegative$[rbp], 1
$LN4@strToInt:

; 81   : 
; 82   : 
; 83   : 		if (*input >= '0' && *input <= '9')

  00069	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR input$[rbp]
  00070	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00073	83 f8 30	 cmp	 eax, 48			; 00000030H
  00076	7c 33		 jl	 SHORT $LN5@strToInt
  00078	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR input$[rbp]
  0007f	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00082	83 f8 39	 cmp	 eax, 57			; 00000039H
  00085	7f 24		 jg	 SHORT $LN5@strToInt

; 84   : 		{
; 85   : 			numStart = 1;

  00087	c7 45 04 01 00
	00 00		 mov	 DWORD PTR numStart$[rbp], 1

; 86   : 
; 87   : 			output *= 10;

  0008e	6b 45 44 0a	 imul	 eax, DWORD PTR output$[rbp], 10
  00092	89 45 44	 mov	 DWORD PTR output$[rbp], eax

; 88   : 			output += *input - 48;

  00095	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR input$[rbp]
  0009c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0009f	8b 4d 44	 mov	 ecx, DWORD PTR output$[rbp]
  000a2	8d 44 01 d0	 lea	 eax, DWORD PTR [rcx+rax-48]
  000a6	89 45 44	 mov	 DWORD PTR output$[rbp], eax

; 89   : 		}

  000a9	eb 08		 jmp	 SHORT $LN6@strToInt
$LN5@strToInt:

; 90   : 		else if (numStart)

  000ab	83 7d 04 00	 cmp	 DWORD PTR numStart$[rbp], 0
  000af	74 02		 je	 SHORT $LN7@strToInt

; 91   : 			break;

  000b1	eb 16		 jmp	 SHORT $LN3@strToInt
$LN7@strToInt:
$LN6@strToInt:

; 92   : 
; 93   : 		input++;

  000b3	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR input$[rbp]
  000ba	48 ff c0	 inc	 rax
  000bd	48 89 85 80 01
	00 00		 mov	 QWORD PTR input$[rbp], rax

; 94   : 	}

  000c4	e9 76 ff ff ff	 jmp	 $LN2@strToInt
$LN3@strToInt:

; 95   : 
; 96   : 	output *= isNegative ? -1 : 1;

  000c9	83 7d 24 00	 cmp	 DWORD PTR isNegative$[rbp], 0
  000cd	74 0c		 je	 SHORT $LN9@strToInt
  000cf	c7 85 54 01 00
	00 ff ff ff ff	 mov	 DWORD PTR tv80[rbp], -1
  000d9	eb 0a		 jmp	 SHORT $LN10@strToInt
$LN9@strToInt:
  000db	c7 85 54 01 00
	00 01 00 00 00	 mov	 DWORD PTR tv80[rbp], 1
$LN10@strToInt:
  000e5	8b 45 44	 mov	 eax, DWORD PTR output$[rbp]
  000e8	0f af 85 54 01
	00 00		 imul	 eax, DWORD PTR tv80[rbp]
  000ef	89 45 44	 mov	 DWORD PTR output$[rbp], eax

; 97   : 
; 98   : 	return output;

  000f2	8b 45 44	 mov	 eax, DWORD PTR output$[rbp]

; 99   : }

  000f5	48 8d a5 68 01
	00 00		 lea	 rsp, QWORD PTR [rbp+360]
  000fc	5f		 pop	 rdi
  000fd	5d		 pop	 rbp
  000fe	c3		 ret	 0
strToInt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tPreent.c
;	COMDAT integerConvert
_TEXT	SEGMENT
ptr$ = 8
num$ = 256
base$ = 264
integerConvert PROC					; COMDAT

; 44   : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	55		 push	 rbp
  00009	57		 push	 rdi
  0000a	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00011	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__386B16A1_tPreent@c
  0001d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 45   : 	static char Representation[] = "0123456789ABCDEF";
; 46   : 	static char iBuffer[MAX_NUM_BUFFER];
; 47   : 
; 48   : 
; 49   : 	char* ptr = &iBuffer[MAX_NUM_BUFFER - 1];

  00022	b8 01 00 00 00	 mov	 eax, 1
  00027	48 6b c0 31	 imul	 rax, rax, 49		; 00000031H
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?iBuffer@?1??integerConvert@@9@9
  00032	48 03 c8	 add	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	48 89 45 08	 mov	 QWORD PTR ptr$[rbp], rax

; 50   : 	*ptr = '\0';

  0003c	48 8b 45 08	 mov	 rax, QWORD PTR ptr$[rbp]
  00040	c6 00 00	 mov	 BYTE PTR [rax], 0
$LN4@integerCon:

; 51   : 
; 52   : 	do
; 53   : 	{
; 54   : 		ptr -= 1;

  00043	48 8b 45 08	 mov	 rax, QWORD PTR ptr$[rbp]
  00047	48 ff c8	 dec	 rax
  0004a	48 89 45 08	 mov	 QWORD PTR ptr$[rbp], rax

; 55   : 		*ptr = Representation[num % base];

  0004e	33 d2		 xor	 edx, edx
  00050	8b 85 00 01 00
	00		 mov	 eax, DWORD PTR num$[rbp]
  00056	f7 b5 08 01 00
	00		 div	 DWORD PTR base$[rbp]
  0005c	8b c2		 mov	 eax, edx
  0005e	8b c0		 mov	 eax, eax
  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Representation@?1??integerConvert@@9@9
  00067	48 8b 55 08	 mov	 rdx, QWORD PTR ptr$[rbp]
  0006b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0006f	88 02		 mov	 BYTE PTR [rdx], al

; 56   : 		num /= base;

  00071	33 d2		 xor	 edx, edx
  00073	8b 85 00 01 00
	00		 mov	 eax, DWORD PTR num$[rbp]
  00079	f7 b5 08 01 00
	00		 div	 DWORD PTR base$[rbp]
  0007f	89 85 00 01 00
	00		 mov	 DWORD PTR num$[rbp], eax

; 57   : 	} while (num != 0);

  00085	83 bd 00 01 00
	00 00		 cmp	 DWORD PTR num$[rbp], 0
  0008c	75 b5		 jne	 SHORT $LN4@integerCon

; 58   : 
; 59   : 	return(ptr);

  0008e	48 8b 45 08	 mov	 rax, QWORD PTR ptr$[rbp]

; 60   : }

  00092	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00099	5f		 pop	 rdi
  0009a	5d		 pop	 rbp
  0009b	c3		 ret	 0
integerConvert ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tPreent.c
;	COMDAT pootStr
_TEXT	SEGMENT
length$ = 4
str$ = 256
output$ = 264
written$ = 272
pootStr	PROC						; COMDAT

; 27   : {

$LN4:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00018	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__386B16A1_tPreent@c
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 28   : 	//HANDLE output = GetStdHandle(STD_OUTPUT_HANDLE);
; 29   : 	//DWORD written = 0;
; 30   : 
; 31   : 	//while (*str != '\0')
; 32   : 	//{
; 33   : 	unsigned int length = strLenSafe(str);

  00029	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR str$[rbp]
  00030	e8 00 00 00 00	 call	 strLenSafe
  00035	89 45 04	 mov	 DWORD PTR length$[rbp], eax

; 34   : 
; 35   : 	if (!length)

  00038	83 7d 04 00	 cmp	 DWORD PTR length$[rbp], 0
  0003c	75 02		 jne	 SHORT $LN2@pootStr

; 36   : 		return;

  0003e	eb 28		 jmp	 SHORT $LN1@pootStr
$LN2@pootStr:

; 37   : 
; 38   : 	WriteConsoleA(output, str, length, &written, NULL);

  00040	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00049	4c 8d 8d 10 01
	00 00		 lea	 r9, QWORD PTR written$[rbp]
  00050	44 8b 45 04	 mov	 r8d, DWORD PTR length$[rbp]
  00054	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR str$[rbp]
  0005b	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR output$[rbp]
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WriteConsoleA
$LN1@pootStr:

; 39   : 	//str++;
; 40   : //}
; 41   : }

  00068	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0006f	5f		 pop	 rdi
  00070	5d		 pop	 rbp
  00071	c3		 ret	 0
pootStr	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tPreent.c
;	COMDAT pootChar
_TEXT	SEGMENT
put$ = 224
output$ = 232
written$ = 240
pootChar PROC						; COMDAT

; 19   : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00017	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__386B16A1_tPreent@c
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 20   : 	//HANDLE output = GetStdHandle(STD_OUTPUT_HANDLE);
; 21   : 	//DWORD written = 0;
; 22   : 
; 23   : 	WriteConsoleA(output, &put, 1, &written, NULL);

  00028	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00031	4c 8d 8d f0 00
	00 00		 lea	 r9, QWORD PTR written$[rbp]
  00038	41 b8 01 00 00
	00		 mov	 r8d, 1
  0003e	48 8d 95 e0 00
	00 00		 lea	 rdx, QWORD PTR put$[rbp]
  00045	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR output$[rbp]
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WriteConsoleA

; 24   : }

  00052	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00059	5f		 pop	 rdi
  0005a	5d		 pop	 rbp
  0005b	c3		 ret	 0
pootChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tPreent.c
;	COMDAT strLenSafe
_TEXT	SEGMENT
count$ = 4
str$ = 256
strLenSafe PROC						; COMDAT

; 4    : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__386B16A1_tPreent@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5    : 	if (!str)

  0001f	48 83 bd 00 01
	00 00 00	 cmp	 QWORD PTR str$[rbp], 0
  00027	75 04		 jne	 SHORT $LN4@strLenSafe

; 6    : 		return 0;

  00029	33 c0		 xor	 eax, eax
  0002b	eb 34		 jmp	 SHORT $LN1@strLenSafe
$LN4@strLenSafe:

; 7    : 	unsigned int count = 1;

  0002d	c7 45 04 01 00
	00 00		 mov	 DWORD PTR count$[rbp], 1
$LN2@strLenSafe:

; 8    : 	while (str[count - 1] != '\0')

  00034	8b 45 04	 mov	 eax, DWORD PTR count$[rbp]
  00037	ff c8		 dec	 eax
  00039	8b c0		 mov	 eax, eax
  0003b	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR str$[rbp]
  00042	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00046	85 c0		 test	 eax, eax
  00048	74 14		 je	 SHORT $LN3@strLenSafe

; 9    : 	{
; 10   : 		if (count > MAX_CONSOLE_BUFFER)

  0004a	83 7d 04 40	 cmp	 DWORD PTR count$[rbp], 64 ; 00000040H
  0004e	76 04		 jbe	 SHORT $LN5@strLenSafe

; 11   : 			return 0;

  00050	33 c0		 xor	 eax, eax
  00052	eb 0d		 jmp	 SHORT $LN1@strLenSafe
$LN5@strLenSafe:

; 12   : 		count++;

  00054	8b 45 04	 mov	 eax, DWORD PTR count$[rbp]
  00057	ff c0		 inc	 eax
  00059	89 45 04	 mov	 DWORD PTR count$[rbp], eax

; 13   : 	}

  0005c	eb d6		 jmp	 SHORT $LN2@strLenSafe
$LN3@strLenSafe:

; 14   : 
; 15   : 	return count;

  0005e	8b 45 04	 mov	 eax, DWORD PTR count$[rbp]
$LN1@strLenSafe:

; 16   : }

  00061	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00068	5f		 pop	 rdi
  00069	5d		 pop	 rbp
  0006a	c3		 ret	 0
strLenSafe ENDP
_TEXT	ENDS
END
