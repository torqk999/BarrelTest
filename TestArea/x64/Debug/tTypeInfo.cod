; Listing generated by Microsoft (R) Optimizing Compiler Version 19.39.33523.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	testTypeBinCurrentCount
PUBLIC	testPropertyBinCurrentCount
PUBLIC	testNullBinHead
_DATA	SEGMENT
COMM	testTypeBin:BYTE:0300H
COMM	testPropertyBin:BYTE:0400H
_DATA	ENDS
_BSS	SEGMENT
testTypeBinCurrentCount DD 01H DUP (?)
testPropertyBinCurrentCount DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	testNullBin:BYTE:01000H
_DATA	ENDS
msvcjmc	SEGMENT
__9C67CA7D_tEnums@h DB 01H
__EAEE5CFA_tDefines@h DB 01H
__0ED14FEE_winpackagefamily@h DB 01H
__F92EF742_winapifamily@h DB 01H
__22E515EB_sdkddkver@h DB 01H
__FE09AF47_concurrencysal@h DB 01H
__C073CA79_sal@h DB 01H
__D6AFE870_vadefs@h DB 01H
__D63E96CF_vcruntime@h DB 01H
__514B86D7_excpt@h DB 01H
__9A7D38D9_stdarg@h DB 01H
__29F49F40_specstrings_undef@h DB 01H
__D0F42932_specstrings_strict@h DB 01H
__F00405FD_sdv_driverspecs@h DB 01H
__173E09CA_driverspecs@h DB 01H
__9A452361_specstrings@h DB 01H
__1B0272D9_corecrt@h DB 01H
__74484FB3_corecrt_wctype@h DB 01H
__1EC467ED_ctype@h DB 01H
__98517906_kernelspecs@h DB 01H
__D3497022_basetsd@h DB 01H
__61CC25A1_errno@h DB 01H
__3EADF068_vcruntime_string@h DB 01H
__E4C945B4_corecrt_memcpy_s@h DB 01H
__8EAFF484_corecrt_memory@h DB 01H
__6490AEC5_corecrt_wstring@h DB 01H
__E8295E1E_string@h DB 01H
__7FCB5136_guiddef@h DB 01H
__FF8A9E11_pshpack4@h DB 01H
__D5438902_poppack@h DB 01H
__FB07E2A3_pshpack2@h DB 01H
__F6906775_pshpack8@h DB 01H
__F9415CFA_pshpack1@h DB 01H
__E58C6F1C_apiset@h DB 01H
__A5C52262_ktmtypes@h DB 01H
__FBBA8F9D_winnt@h DB 01H
__A32D3D2C_minwindef@h DB 01H
__7D798299_windef@h DB 01H
__9AE108E9_apisetcconv@h DB 01H
__9CE53D2C_minwinbase@h DB 01H
__5D0AA210_apiquery2@h DB 01H
__4DD4E726_processenv@h DB 01H
__3575CC96_fileapi@h DB 01H
__8EA220E6_fileapifromapp@h DB 01H
__BF9B31FE_debugapi@h DB 01H
__C3AFE134_utilapiset@h DB 01H
__76F69E51_handleapi@h DB 01H
__7E63D784_errhandlingapi@h DB 01H
__FFA7003C_fibersapi@h DB 01H
__8971CECF_namedpipeapi@h DB 01H
__46C9D8A6_profileapi@h DB 01H
__98D4F0A3_heapapi@h DB 01H
__50EF2A88_ioapiset@h DB 01H
__92EA1464_synchapi@h DB 01H
__A53D8AED_interlockedapi@h DB 01H
__B506CAAF_processthreadsapi@h DB 01H
__FF735694_sysinfoapi@h DB 01H
__29589789_memoryapi@h DB 01H
__E9C7A663_enclaveapi@h DB 01H
__D035F9F7_threadpoollegacyapiset@h DB 01H
__C899130C_threadpoolapiset@h DB 01H
__E0441EE7_jobapi@h DB 01H
__CEF86838_jobapi2@h DB 01H
__35AC6B9A_wow64apiset@h DB 01H
__C8AE41A5_libloaderapi@h DB 01H
__CC9E232D_securitybaseapi@h DB 01H
__C9D0C9B8_namespaceapi@h DB 01H
__30FF9CAD_systemtopologyapi@h DB 01H
__4D358795_processtopologyapi@h DB 01H
__40446D10_securityappcontainer@h DB 01H
__3A952EDF_realtimeapiset@h DB 01H
__F4865F4B_winerror@h DB 01H
__53C1BD93_timezoneapi@h DB 01H
__1FFBEDBF_winbase@h DB 01H
__43D3FA34_wingdi@h DB 01H
__D24A7391_tvout@h DB 01H
__7713A6C8_winuser@h DB 01H
__0B345F71_datetimeapi@h DB 01H
__9AC6960C_winnls@h DB 01H
__973A40A8_stringapiset@h DB 01H
__CC46FEE2_wincontypes@h DB 01H
__97D70BE1_consoleapi@h DB 01H
__27EC5E18_consoleapi2@h DB 01H
__262E342F_consoleapi3@h DB 01H
__641DCD70_wincon@h DB 01H
__5A96C7A7_verrsrc@h DB 01H
__B69C6FF2_winver@h DB 01H
__7AEB8C37_reason@h DB 01H
__59F1A8A9_winreg@h DB 01H
__EE0E2B7F_wnnc@h DB 01H
__DCDB7054_winnetwk@h DB 01H
__EDC72EEB_cderr@h DB 01H
__95F9199D_dde@h DB 01H
__66427627_ddeml@h DB 01H
__957C29A0_dlgs@h DB 01H
__12EA15AF_lzexpand@h DB 01H
__62131F15_mmsyscom@h DB 01H
__47E68D49_mciapi@h DB 01H
__5D7DD356_mmiscapi@h DB 01H
__7223D2EF_mmiscapi2@h DB 01H
__A330DBB3_playsoundapi@h DB 01H
__601B366F_mmeapi@h DB 01H
__1134ADD5_timeapi@h DB 01H
__93F2265A_joystickapi@h DB 01H
__DF6EB4E3_mmsystem@h DB 01H
__BD641FCB_nb30@h DB 01H
__DF8704F0_rpcdcep@h DB 01H
__5C6CA7BB_rpcdce@h DB 01H
__853533C4_rpcnsi@h DB 01H
__2D2406C3_rpcnterr@h DB 01H
__64521D71_rpcasync@h DB 01H
__AADCBA08_rpc@h DB 01H
__19E26CFF_shellapi@h DB 01H
__1E9F31D3_winperf@h DB 01H
__832A4112_inaddr@h DB 01H
__32C6F875_winsock@h DB 01H
__7953A3F8_bcrypt@h DB 01H
__E4169492_ncrypt@h DB 01H
__AF3DDDC3_dpapi@h DB 01H
__D1E23BF2_wincrypt@h DB 01H
__82AB4779_winefs@h DB 01H
__1FE431C9_rpcnsip@h DB 01H
__2B741F2D_rpcsal@h DB 01H
__92623256_rpcndr@h DB 01H
__9C18532E_wtypesbase@h DB 01H
__EA2E1D6D_wtypes@h DB 01H
__7DDD9F45_winioctl@h DB 01H
__E550A843_winsmcrd@h DB 01H
__9809C1BA_winscard@h DB 01H
__EA174FA4_prsht@h DB 01H
__0E1BD114_winspool@h DB 01H
__45DED006_corecrt_malloc@h DB 01H
__13F5961F_stddef@h DB 01H
__FD6DBD68_corecrt_search@h DB 01H
__E2E33A61_corecrt_wstdlib@h DB 01H
__10D4A829_limits@h DB 01H
__6E5ACABA_stdlib@h DB 01H
__30B1AFDA_unknwnbase@h DB 01H
__328C1996_objidlbase@h DB 01H
__C4E06B6A_cguid@h DB 01H
__434718C5_combaseapi@h DB 01H
__DE6FDEF1_unknwn@h DB 01H
__CCE0BACC_objidl@h DB 01H
__8C7011E5_oaidl@h DB 01H
__2E0B7863_propidlbase@h DB 01H
__BF4CF2EC_coml2api@h DB 01H
__6D897344_oleidl@h DB 01H
__1129FC2C_servprov@h DB 01H
__757952E4_msxml@h DB 01H
__B1191D53_urlmon@h DB 01H
__404D1A47_propidl@h DB 01H
__A1C63593_objbase@h DB 01H
__C1B0A9CB_oleauto@h DB 01H
__24EAF61F_ole2@h DB 01H
__2B1843DA_commdlg@h DB 01H
__81DDEDE3_stralign@h DB 01H
__2134D1B4_winsvc@h DB 01H
__11C07376_mcx@h DB 01H
__577CE3E7_ime_cmodes@h DB 01H
__1E72C31E_imm@h DB 01H
__63AA7AF5_Windows@h DB 01H
__4EC676C0_tModules@h DB 01H
__AFB9CF29_tPreent@h DB 01H
__366DFDC4_tHelpers@h DB 01H
__D300D227_tTypeInfo@h DB 01H
__44D20BAF_tTypeInfo@c DB 01H
msvcjmc	ENDS
_DATA	SEGMENT
testNullBinHead DQ FLAT:testNullBin
_DATA	ENDS
PUBLIC	TypeInfo_Compare
PUBLIC	TypeInfo_GetNullable
PUBLIC	TypeInfo_GetInfo
PUBLIC	Property_Get
PUBLIC	TypeInfo_Get
PUBLIC	TypeInfo_Name
PUBLIC	TypeInfo_Size
PUBLIC	TypeInfo_BuildTypeFlags
PUBLIC	TypeInfo_BuildMemFlags
PUBLIC	TypeInfo_GetNullableTemplate
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_08CLLOMHGD@unsigned@			; `string'
PUBLIC	??_C@_05KNFBNCOH@float@				; `string'
PUBLIC	??_C@_06BNJCAIGJ@double@			; `string'
PUBLIC	??_C@_03JBIPMCLC@int@				; `string'
PUBLIC	??_C@_04GOKPGOLB@long@				; `string'
PUBLIC	??_C@_05BFKKPKCG@short@				; `string'
PUBLIC	??_C@_04ENMBGAPA@char@				; `string'
PUBLIC	??_C@_05BNCCCJPP@const@				; `string'
PUBLIC	??_C@_06GGHJAEBN@static@			; `string'
PUBLIC	??_C@_08PABEKFH@volatile@			; `string'
PUBLIC	??_C@_0BM@KPOEFPPK@No?5type?5slots?5available?4?4?4?6@ ; `string'
EXTRN	Preent:PROC
EXTRN	defaultStringCompare:PROC
EXTRN	findSubString:PROC
EXTRN	rawTranscribe:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$TypeInfo_Compare DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$TypeInfo_Compare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TypeInfo_GetNullable DD imagerel $LN8
	DD	imagerel $LN8+364
	DD	imagerel $unwind$TypeInfo_GetNullable
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TypeInfo_GetInfo DD imagerel $LN8
	DD	imagerel $LN8+203
	DD	imagerel $unwind$TypeInfo_GetInfo
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Property_Get DD imagerel $LN8
	DD	imagerel $LN8+328
	DD	imagerel $unwind$Property_Get
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TypeInfo_Get DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$TypeInfo_Get
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TypeInfo_Name DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$TypeInfo_Name
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TypeInfo_Size DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$TypeInfo_Size
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TypeInfo_BuildTypeFlags DD imagerel $LN12
	DD	imagerel $LN12+270
	DD	imagerel $unwind$TypeInfo_BuildTypeFlags
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TypeInfo_BuildMemFlags DD imagerel $LN6
	DD	imagerel $LN6+150
	DD	imagerel $unwind$TypeInfo_BuildMemFlags
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TypeInfo_GetNullableTemplate DD imagerel $LN5
	DD	imagerel $LN5+180
	DD	imagerel $unwind$TypeInfo_GetNullableTemplate
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BM@KPOEFPPK@No?5type?5slots?5available?4?4?4?6@
CONST	SEGMENT
??_C@_0BM@KPOEFPPK@No?5type?5slots?5available?4?4?4?6@ DB 'No type slots '
	DB	'available...', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08PABEKFH@volatile@
CONST	SEGMENT
??_C@_08PABEKFH@volatile@ DB 'volatile', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GGHJAEBN@static@
CONST	SEGMENT
??_C@_06GGHJAEBN@static@ DB 'static', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BNCCCJPP@const@
CONST	SEGMENT
??_C@_05BNCCCJPP@const@ DB 'const', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04ENMBGAPA@char@
CONST	SEGMENT
??_C@_04ENMBGAPA@char@ DB 'char', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05BFKKPKCG@short@
CONST	SEGMENT
??_C@_05BFKKPKCG@short@ DB 'short', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GOKPGOLB@long@
CONST	SEGMENT
??_C@_04GOKPGOLB@long@ DB 'long', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBIPMCLC@int@
CONST	SEGMENT
??_C@_03JBIPMCLC@int@ DB 'int', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06BNJCAIGJ@double@
CONST	SEGMENT
??_C@_06BNJCAIGJ@double@ DB 'double', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KNFBNCOH@float@
CONST	SEGMENT
??_C@_05KNFBNCOH@float@ DB 'float', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08CLLOMHGD@unsigned@
CONST	SEGMENT
??_C@_08CLLOMHGD@unsigned@ DB 'unsigned', 00H		; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TypeInfo_GetNullableTemplate DD 025051801H
	DD	01132318H
	DD	0700c0029H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TypeInfo_BuildMemFlags DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TypeInfo_BuildTypeFlags DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TypeInfo_Size DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TypeInfo_Name DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TypeInfo_Get DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03bH
	DW	012fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Property_Get DD 025054219H
	DD	01132318H
	DD	0700c002fH
	DD	0500bH
	DD	imagerel __GSHandlerCheck
	DD	0168H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
Property_Get$rtcName$0 DB 024H
	DB	053H
	DB	031H
	DB	00H
	ORG $+4
Property_Get$rtcName$1 DB 06eH
	DB	065H
	DB	077H
	DB	050H
	DB	072H
	DB	06fH
	DB	070H
	DB	00H
Property_Get$rtcVarDesc DD 068H
	DD	010H
	DQ	FLAT:Property_Get$rtcName$1
	DD	048H
	DD	00H
	DQ	FLAT:Property_Get$rtcName$0
	ORG $+96
Property_Get$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:Property_Get$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TypeInfo_GetInfo DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	040H
	DW	0153H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TypeInfo_GetNullable DD 025054719H
	DD	0118231dH
	DD	070110033H
	DD	05010H
	DD	imagerel __GSHandlerCheck
	DD	0188H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
TypeInfo_GetNullable$rtcName$0 DB 024H
	DB	053H
	DB	032H
	DB	00H
	ORG $+4
TypeInfo_GetNullable$rtcName$1 DB 06eH
	DB	065H
	DB	077H
	DB	049H
	DB	06eH
	DB	066H
	DB	06fH
	DB	00H
TypeInfo_GetNullable$rtcVarDesc DD 088H
	DD	018H
	DQ	FLAT:TypeInfo_GetNullable$rtcName$1
	DD	048H
	DD	00H
	DQ	FLAT:TypeInfo_GetNullable$rtcName$0
	ORG $+96
TypeInfo_GetNullable$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:TypeInfo_GetNullable$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TypeInfo_Compare DD 025051801H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	c2 00 00	 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tTypeInfo.c
;	COMDAT TypeInfo_GetNullableTemplate
_TEXT	SEGMENT
endOfPage$ = 8
headLoc$ = 40
ptr$ = 72
size$ = 320
nullLoc$ = 328
TypeInfo_GetNullableTemplate PROC			; COMDAT

; 121  : void* TypeInfo_GetNullableTemplate(size_t size, void* nullLoc) {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__44D20BAF_tTypeInfo@c
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 122  : 	if (!nullLoc)

  00024	48 83 bd 48 01
	00 00 00	 cmp	 QWORD PTR nullLoc$[rbp], 0
  0002c	75 04		 jne	 SHORT $LN2@TypeInfo_G

; 123  : 		return NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	eb 78		 jmp	 SHORT $LN1@TypeInfo_G
$LN2@TypeInfo_G:

; 124  : 
; 125  : 	size_t endOfPage = &testNullBin + sizeof(Page);

  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:testNullBin
  00039	48 05 00 00 00
	01		 add	 rax, 16777216		; 01000000H
  0003f	48 89 45 08	 mov	 QWORD PTR endOfPage$[rbp], rax

; 126  : 	size_t headLoc = testNullBinHead;

  00043	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR testNullBinHead
  0004a	48 89 45 28	 mov	 QWORD PTR headLoc$[rbp], rax

; 127  : 	if (headLoc + size > endOfPage)

  0004e	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR size$[rbp]
  00055	48 8b 4d 28	 mov	 rcx, QWORD PTR headLoc$[rbp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	48 3b 45 08	 cmp	 rax, QWORD PTR endOfPage$[rbp]
  00063	76 04		 jbe	 SHORT $LN3@TypeInfo_G

; 128  : 		return NULL;

  00065	33 c0		 xor	 eax, eax
  00067	eb 41		 jmp	 SHORT $LN1@TypeInfo_G
$LN3@TypeInfo_G:

; 129  : 
; 130  : 	rawTranscribe(testNullBinHead, nullLoc, size);

  00069	4c 8b 85 40 01
	00 00		 mov	 r8, QWORD PTR size$[rbp]
  00070	48 8b 95 48 01
	00 00		 mov	 rdx, QWORD PTR nullLoc$[rbp]
  00077	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR testNullBinHead
  0007e	e8 00 00 00 00	 call	 rawTranscribe

; 131  : 	void* ptr = testNullBinHead;

  00083	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR testNullBinHead
  0008a	48 89 45 48	 mov	 QWORD PTR ptr$[rbp], rax

; 132  : 	testNullBinHead = headLoc + size;

  0008e	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR size$[rbp]
  00095	48 8b 4d 28	 mov	 rcx, QWORD PTR headLoc$[rbp]
  00099	48 03 c8	 add	 rcx, rax
  0009c	48 8b c1	 mov	 rax, rcx
  0009f	48 89 05 00 00
	00 00		 mov	 QWORD PTR testNullBinHead, rax

; 133  : 	return ptr;

  000a6	48 8b 45 48	 mov	 rax, QWORD PTR ptr$[rbp]
$LN1@TypeInfo_G:

; 134  : }

  000aa	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  000b1	5f		 pop	 rdi
  000b2	5d		 pop	 rbp
  000b3	c3		 ret	 0
TypeInfo_GetNullableTemplate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tTypeInfo.c
;	COMDAT TypeInfo_BuildMemFlags
_TEXT	SEGMENT
flags$ = 4
name$ = 256
TypeInfo_BuildMemFlags PROC				; COMDAT

; 79   : int TypeInfo_BuildMemFlags(const char* name) {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__44D20BAF_tTypeInfo@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 80   : 	int flags = 0;

  0001f	c7 45 04 00 00
	00 00		 mov	 DWORD PTR flags$[rbp], 0

; 81   : 
; 82   : 	if (findSubString(name, "const") > -1)

  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05BNCCCJPP@const@
  0002d	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR name$[rbp]
  00034	e8 00 00 00 00	 call	 findSubString
  00039	83 f8 ff	 cmp	 eax, -1
  0003c	7e 09		 jle	 SHORT $LN2@TypeInfo_B

; 83   : 		flags |= READ_ONLY | FIXED_SIZE;

  0003e	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]
  00041	83 c8 03	 or	 eax, 3
  00044	89 45 04	 mov	 DWORD PTR flags$[rbp], eax
$LN2@TypeInfo_B:

; 84   : 
; 85   : 	if (findSubString(name, "static") > -1)

  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06GGHJAEBN@static@
  0004e	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR name$[rbp]
  00055	e8 00 00 00 00	 call	 findSubString
  0005a	83 f8 ff	 cmp	 eax, -1
  0005d	7e 09		 jle	 SHORT $LN3@TypeInfo_B

; 86   : 		flags |= STATIC;

  0005f	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]
  00062	83 c8 04	 or	 eax, 4
  00065	89 45 04	 mov	 DWORD PTR flags$[rbp], eax
$LN3@TypeInfo_B:

; 87   : 
; 88   : 	if (findSubString(name, "volatile") > -1)

  00068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08PABEKFH@volatile@
  0006f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR name$[rbp]
  00076	e8 00 00 00 00	 call	 findSubString
  0007b	83 f8 ff	 cmp	 eax, -1
  0007e	7e 09		 jle	 SHORT $LN4@TypeInfo_B

; 89   : 		flags |= VOLATILE;

  00080	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]
  00083	83 c8 08	 or	 eax, 8
  00086	89 45 04	 mov	 DWORD PTR flags$[rbp], eax
$LN4@TypeInfo_B:

; 90   : 
; 91   : 	return flags;

  00089	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]

; 92   : }

  0008c	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00093	5f		 pop	 rdi
  00094	5d		 pop	 rbp
  00095	c3		 ret	 0
TypeInfo_BuildMemFlags ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tTypeInfo.c
;	COMDAT TypeInfo_BuildTypeFlags
_TEXT	SEGMENT
flags$ = 4
name$ = 256
TypeInfo_BuildTypeFlags PROC				; COMDAT

; 53   : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__44D20BAF_tTypeInfo@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 54   : 	int flags = 0;

  0001f	c7 45 04 00 00
	00 00		 mov	 DWORD PTR flags$[rbp], 0

; 55   : 
; 56   : 	if (findSubString(name, "unsigned") > -1)

  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08CLLOMHGD@unsigned@
  0002d	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR name$[rbp]
  00034	e8 00 00 00 00	 call	 findSubString
  00039	83 f8 ff	 cmp	 eax, -1
  0003c	7e 09		 jle	 SHORT $LN2@TypeInfo_B

; 57   : 		flags |= UNSIGNED;

  0003e	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]
  00041	83 c8 20	 or	 eax, 32			; 00000020H
  00044	89 45 04	 mov	 DWORD PTR flags$[rbp], eax
$LN2@TypeInfo_B:

; 58   : 
; 59   : 	if (findSubString(name, "float") > -1 ||

  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05KNFBNCOH@float@
  0004e	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR name$[rbp]
  00055	e8 00 00 00 00	 call	 findSubString
  0005a	83 f8 ff	 cmp	 eax, -1
  0005d	7f 18		 jg	 SHORT $LN5@TypeInfo_B
  0005f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06BNJCAIGJ@double@
  00066	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR name$[rbp]
  0006d	e8 00 00 00 00	 call	 findSubString
  00072	83 f8 ff	 cmp	 eax, -1
  00075	7e 0b		 jle	 SHORT $LN3@TypeInfo_B
$LN5@TypeInfo_B:

; 60   : 		findSubString(name, "double") > -1)
; 61   : 		flags |= FLOATING;

  00077	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]
  0007a	83 c8 04	 or	 eax, 4
  0007d	89 45 04	 mov	 DWORD PTR flags$[rbp], eax
  00080	eb 7f		 jmp	 SHORT $LN4@TypeInfo_B
$LN3@TypeInfo_B:

; 62   : 
; 63   : 	else if
; 64   : 		(findSubString(name, "int") > -1 ||
; 65   : 			findSubString(name, "long") > -1 ||

  00082	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03JBIPMCLC@int@
  00089	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR name$[rbp]
  00090	e8 00 00 00 00	 call	 findSubString
  00095	83 f8 ff	 cmp	 eax, -1
  00098	7f 30		 jg	 SHORT $LN8@TypeInfo_B
  0009a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GOKPGOLB@long@
  000a1	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR name$[rbp]
  000a8	e8 00 00 00 00	 call	 findSubString
  000ad	83 f8 ff	 cmp	 eax, -1
  000b0	7f 18		 jg	 SHORT $LN8@TypeInfo_B
  000b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05BFKKPKCG@short@
  000b9	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR name$[rbp]
  000c0	e8 00 00 00 00	 call	 findSubString
  000c5	83 f8 ff	 cmp	 eax, -1
  000c8	7e 0b		 jle	 SHORT $LN6@TypeInfo_B
$LN8@TypeInfo_B:

; 66   : 			findSubString(name, "short") > -1)
; 67   : 		flags |= INTEGRAL;

  000ca	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]
  000cd	83 c8 02	 or	 eax, 2
  000d0	89 45 04	 mov	 DWORD PTR flags$[rbp], eax
  000d3	eb 2c		 jmp	 SHORT $LN7@TypeInfo_B
$LN6@TypeInfo_B:

; 68   : 
; 69   : 	else if
; 70   : 		(findSubString(name, "char") > -1)

  000d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04ENMBGAPA@char@
  000dc	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR name$[rbp]
  000e3	e8 00 00 00 00	 call	 findSubString
  000e8	83 f8 ff	 cmp	 eax, -1
  000eb	7e 0b		 jle	 SHORT $LN9@TypeInfo_B

; 71   : 		flags |= ALPHA;

  000ed	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]
  000f0	83 c8 01	 or	 eax, 1
  000f3	89 45 04	 mov	 DWORD PTR flags$[rbp], eax
  000f6	eb 09		 jmp	 SHORT $LN10@TypeInfo_B
$LN9@TypeInfo_B:

; 72   : 
; 73   : 	else
; 74   : 		flags |= TYPE_DEF;

  000f8	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]
  000fb	83 c8 08	 or	 eax, 8
  000fe	89 45 04	 mov	 DWORD PTR flags$[rbp], eax
$LN10@TypeInfo_B:
$LN7@TypeInfo_B:
$LN4@TypeInfo_B:

; 75   : 
; 76   : 	return flags;

  00101	8b 45 04	 mov	 eax, DWORD PTR flags$[rbp]

; 77   : }

  00104	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0010b	5f		 pop	 rdi
  0010c	5d		 pop	 rbp
  0010d	c3		 ret	 0
TypeInfo_BuildTypeFlags ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tTypeInfo.c
;	COMDAT TypeInfo_Size
_TEXT	SEGMENT
collection$ = 224
TypeInfo_Size PROC					; COMDAT

; 146  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__44D20BAF_tTypeInfo@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 147  : 	return collection->_extensions->_type->_size;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR collection$[rbp]
  00026	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00029	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 148  : }

  00030	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00037	5f		 pop	 rdi
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
TypeInfo_Size ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tTypeInfo.c
;	COMDAT TypeInfo_Name
_TEXT	SEGMENT
collection$ = 224
TypeInfo_Name PROC					; COMDAT

; 141  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__44D20BAF_tTypeInfo@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 142  : 	return collection->_extensions->_type->_name;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR collection$[rbp]
  00026	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00029	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002c	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 143  : }

  0002f	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00036	5f		 pop	 rdi
  00037	5d		 pop	 rbp
  00038	c3		 ret	 0
TypeInfo_Name ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tTypeInfo.c
;	COMDAT TypeInfo_Get
_TEXT	SEGMENT
name$ = 224
size$ = 232
TypeInfo_Get PROC					; COMDAT

; 221  : TypeInfo* TypeInfo_Get(const char* name, size_t size) { return TypeInfo_GetNullable(name, size, NULL); }

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__44D20BAF_tTypeInfo@c
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
  00024	45 33 c0	 xor	 r8d, r8d
  00027	48 8b 95 e8 00
	00 00		 mov	 rdx, QWORD PTR size$[rbp]
  0002e	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR name$[rbp]
  00035	e8 00 00 00 00	 call	 TypeInfo_GetNullable
  0003a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00041	5f		 pop	 rdi
  00042	5d		 pop	 rbp
  00043	c3		 ret	 0
TypeInfo_Get ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tTypeInfo.c
;	COMDAT Property_Get
_TEXT	SEGMENT
i$5 = 4
$S1$6 = 40
newProp$ = 72
ptr$ = 120
__$ArrayPad$ = 328
name$ = 368
info$ = 376
Property_Get PROC					; COMDAT

; 169  : Property* Property_Get(const char* name, TypeInfo* info) {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001d	b9 26 00 00 00	 mov	 ecx, 38			; 00000026H
  00022	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00027	f3 ab		 rep stosd
  00029	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR [rsp+408]
  00031	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00038	48 33 c5	 xor	 rax, rbp
  0003b	48 89 85 48 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__44D20BAF_tTypeInfo@c
  00049	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 170  : 
; 171  : 	for (int i = 0; i < testPropertyBinCurrentCount; i++) {

  0004e	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$5[rbp], 0
  00055	eb 08		 jmp	 SHORT $LN4@Property_G
$LN2@Property_G:
  00057	8b 45 04	 mov	 eax, DWORD PTR i$5[rbp]
  0005a	ff c0		 inc	 eax
  0005c	89 45 04	 mov	 DWORD PTR i$5[rbp], eax
$LN4@Property_G:
  0005f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR testPropertyBinCurrentCount
  00065	39 45 04	 cmp	 DWORD PTR i$5[rbp], eax
  00068	73 3c		 jae	 SHORT $LN3@Property_G

; 172  : 		if (defaultStringCompare(testPropertyBin[i]._name, name))

  0006a	48 63 45 04	 movsxd	 rax, DWORD PTR i$5[rbp]
  0006e	48 6b c0 10	 imul	 rax, rax, 16
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:testPropertyBin
  00079	48 8b 95 70 01
	00 00		 mov	 rdx, QWORD PTR name$[rbp]
  00080	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00084	e8 00 00 00 00	 call	 defaultStringCompare
  00089	85 c0		 test	 eax, eax
  0008b	74 17		 je	 SHORT $LN5@Property_G

; 173  : 			return &testPropertyBin[i];

  0008d	48 63 45 04	 movsxd	 rax, DWORD PTR i$5[rbp]
  00091	48 6b c0 10	 imul	 rax, rax, 16
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:testPropertyBin
  0009c	48 03 c8	 add	 rcx, rax
  0009f	48 8b c1	 mov	 rax, rcx
  000a2	eb 75		 jmp	 SHORT $LN1@Property_G
$LN5@Property_G:

; 174  : 	}

  000a4	eb b1		 jmp	 SHORT $LN2@Property_G
$LN3@Property_G:

; 175  : 
; 176  : 	if (testPropertyBinCurrentCount >= testPropertyBinCount)

  000a6	83 3d 00 00 00
	00 40		 cmp	 DWORD PTR testPropertyBinCurrentCount, 64 ; 00000040H
  000ad	72 14		 jb	 SHORT $LN6@Property_G

; 177  : 	{
; 178  : 		PREENT("No type slots available...\n");

  000af	48 8d 55 28	 lea	 rdx, QWORD PTR $S1$6[rbp]
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@KPOEFPPK@No?5type?5slots?5available?4?4?4?6@
  000ba	e8 00 00 00 00	 call	 Preent

; 179  : 		return NULL;

  000bf	33 c0		 xor	 eax, eax
  000c1	eb 56		 jmp	 SHORT $LN1@Property_G
$LN6@Property_G:

; 180  : 	}
; 181  : 
; 182  : 	Property newProp = {

  000c3	48 8b 85 70 01
	00 00		 mov	 rax, QWORD PTR name$[rbp]
  000ca	48 89 45 48	 mov	 QWORD PTR newProp$[rbp], rax
  000ce	48 8b 85 78 01
	00 00		 mov	 rax, QWORD PTR info$[rbp]
  000d5	48 89 45 50	 mov	 QWORD PTR newProp$[rbp+8], rax

; 183  : 		name,
; 184  : 		info
; 185  : 	};
; 186  : 
; 187  : 	Property* ptr = &testPropertyBin[testPropertyBinCurrentCount];

  000d9	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR testPropertyBinCurrentCount
  000df	48 6b c0 10	 imul	 rax, rax, 16
  000e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:testPropertyBin
  000ea	48 03 c8	 add	 rcx, rax
  000ed	48 8b c1	 mov	 rax, rcx
  000f0	48 89 45 78	 mov	 QWORD PTR ptr$[rbp], rax

; 188  : 	rawTranscribe(ptr, &newProp, sizeof(Property));

  000f4	41 b8 10 00 00
	00		 mov	 r8d, 16
  000fa	48 8d 55 48	 lea	 rdx, QWORD PTR newProp$[rbp]
  000fe	48 8b 4d 78	 mov	 rcx, QWORD PTR ptr$[rbp]
  00102	e8 00 00 00 00	 call	 rawTranscribe

; 189  : 	testPropertyBinCurrentCount++;

  00107	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR testPropertyBinCurrentCount
  0010d	ff c0		 inc	 eax
  0010f	89 05 00 00 00
	00		 mov	 DWORD PTR testPropertyBinCurrentCount, eax

; 190  : 	return ptr;

  00115	48 8b 45 78	 mov	 rax, QWORD PTR ptr$[rbp]
$LN1@Property_G:

; 191  : }

  00119	48 8b f8	 mov	 rdi, rax
  0011c	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  00120	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Property_Get$rtcFrameData
  00127	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0012c	48 8b c7	 mov	 rax, rdi
  0012f	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00136	48 33 cd	 xor	 rcx, rbp
  00139	e8 00 00 00 00	 call	 __security_check_cookie
  0013e	48 8d a5 58 01
	00 00		 lea	 rsp, QWORD PTR [rbp+344]
  00145	5f		 pop	 rdi
  00146	5d		 pop	 rbp
  00147	c3		 ret	 0
Property_Get ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tTypeInfo.c
;	COMDAT TypeInfo_GetInfo
_TEXT	SEGMENT
info$ = 8
tv70 = 212
request$ = 256
TypeInfo_GetInfo PROC					; COMDAT

; 151  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__44D20BAF_tTypeInfo@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 152  : 	TypeInfo* info = request._params[tSRC];

  0001f	b8 08 00 00 00	 mov	 eax, 8
  00024	48 6b c0 02	 imul	 rax, rax, 2
  00028	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR request$[rbp]
  0002f	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00033	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
  00037	48 89 45 08	 mov	 QWORD PTR info$[rbp], rax

; 153  : 
; 154  : 	switch ((ParamType)request._params[tVARIANT]) {

  0003b	b8 08 00 00 00	 mov	 eax, 8
  00040	48 6b c0 00	 imul	 rax, rax, 0
  00044	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR request$[rbp]
  0004b	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0004f	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  00052	89 85 d4 00 00
	00		 mov	 DWORD PTR tv70[rbp], eax
  00058	83 bd d4 00 00
	00 06		 cmp	 DWORD PTR tv70[rbp], 6
  0005f	74 34		 je	 SHORT $LN5@TypeInfo_G
  00061	83 bd d4 00 00
	00 09		 cmp	 DWORD PTR tv70[rbp], 9
  00068	74 02		 je	 SHORT $LN4@TypeInfo_G
  0006a	eb 53		 jmp	 SHORT $LN6@TypeInfo_G
$LN4@TypeInfo_G:

; 155  : 	case tNAME:
; 156  : 		*((char**)request._params[tNAME]) = info->_name;

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 09	 imul	 rax, rax, 9
  00075	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR request$[rbp]
  0007c	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00080	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
  00084	48 8b 4d 08	 mov	 rcx, QWORD PTR info$[rbp]
  00088	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0008b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 157  : 		return true;

  0008e	b8 01 00 00 00	 mov	 eax, 1
  00093	eb 2c		 jmp	 SHORT $LN1@TypeInfo_G
$LN5@TypeInfo_G:

; 158  : 
; 159  : 	case  tSIZE:
; 160  : 		*((size_t*)request._params[tSIZE]) = info->_size;

  00095	b8 08 00 00 00	 mov	 eax, 8
  0009a	48 6b c0 06	 imul	 rax, rax, 6
  0009e	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR request$[rbp]
  000a5	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000a9	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
  000ad	48 8b 4d 08	 mov	 rcx, QWORD PTR info$[rbp]
  000b1	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000b5	48 89 08	 mov	 QWORD PTR [rax], rcx

; 161  : 		return true;

  000b8	b8 01 00 00 00	 mov	 eax, 1
  000bd	eb 02		 jmp	 SHORT $LN1@TypeInfo_G
$LN6@TypeInfo_G:

; 162  : 
; 163  : 
; 164  : 	default:
; 165  : 		return false;

  000bf	33 c0		 xor	 eax, eax
$LN1@TypeInfo_G:

; 166  : 	}
; 167  : }

  000c1	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000c8	5f		 pop	 rdi
  000c9	5d		 pop	 rbp
  000ca	c3		 ret	 0
TypeInfo_GetInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tTypeInfo.c
;	COMDAT TypeInfo_GetNullable
_TEXT	SEGMENT
i$5 = 4
$S2$6 = 40
nullTmp$ = 72
newInfo$ = 104
ptr$ = 152
__$ArrayPad$ = 360
name$ = 400
size$ = 408
nullLoc$ = 416
TypeInfo_GetNullable PROC				; COMDAT

; 195  : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec 98 01
	00 00		 sub	 rsp, 408		; 00000198H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00022	b9 2e 00 00 00	 mov	 ecx, 46			; 0000002eH
  00027	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002c	f3 ab		 rep stosd
  0002e	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR [rsp+440]
  00036	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003d	48 33 c5	 xor	 rax, rbp
  00040	48 89 85 68 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__44D20BAF_tTypeInfo@c
  0004e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 196  : 	for (int i = 0; i < testPropertyBinCount; i++) {

  00053	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$5[rbp], 0
  0005a	eb 08		 jmp	 SHORT $LN4@TypeInfo_G
$LN2@TypeInfo_G:
  0005c	8b 45 04	 mov	 eax, DWORD PTR i$5[rbp]
  0005f	ff c0		 inc	 eax
  00061	89 45 04	 mov	 DWORD PTR i$5[rbp], eax
$LN4@TypeInfo_G:
  00064	83 7d 04 40	 cmp	 DWORD PTR i$5[rbp], 64	; 00000040H
  00068	7d 38		 jge	 SHORT $LN3@TypeInfo_G

; 197  : 		if (testTypeBin[i]._name == name)

  0006a	48 63 45 04	 movsxd	 rax, DWORD PTR i$5[rbp]
  0006e	48 6b c0 18	 imul	 rax, rax, 24
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:testTypeBin
  00079	48 8b 95 90 01
	00 00		 mov	 rdx, QWORD PTR name$[rbp]
  00080	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  00084	75 1a		 jne	 SHORT $LN5@TypeInfo_G

; 198  : 			return &testTypeBin[i];

  00086	48 63 45 04	 movsxd	 rax, DWORD PTR i$5[rbp]
  0008a	48 6b c0 18	 imul	 rax, rax, 24
  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:testTypeBin
  00095	48 03 c8	 add	 rcx, rax
  00098	48 8b c1	 mov	 rax, rcx
  0009b	e9 9d 00 00 00	 jmp	 $LN1@TypeInfo_G
$LN5@TypeInfo_G:

; 199  : 	}

  000a0	eb ba		 jmp	 SHORT $LN2@TypeInfo_G
$LN3@TypeInfo_G:

; 200  : 
; 201  : 	if (testTypeBinCurrentCount >= testTypeBinCount)

  000a2	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR testTypeBinCurrentCount, 32 ; 00000020H
  000a9	72 14		 jb	 SHORT $LN6@TypeInfo_G

; 202  : 	{
; 203  : 		PREENT("No type slots available...\n");

  000ab	48 8d 55 28	 lea	 rdx, QWORD PTR $S2$6[rbp]
  000af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@KPOEFPPK@No?5type?5slots?5available?4?4?4?6@
  000b6	e8 00 00 00 00	 call	 Preent

; 204  : 		return NULL;

  000bb	33 c0		 xor	 eax, eax
  000bd	eb 7e		 jmp	 SHORT $LN1@TypeInfo_G
$LN6@TypeInfo_G:

; 205  : 	}
; 206  : 
; 207  : 	void* nullTmp = TypeInfo_GetNullableTemplate(size, nullLoc);

  000bf	48 8b 95 a0 01
	00 00		 mov	 rdx, QWORD PTR nullLoc$[rbp]
  000c6	48 8b 8d 98 01
	00 00		 mov	 rcx, QWORD PTR size$[rbp]
  000cd	e8 00 00 00 00	 call	 TypeInfo_GetNullableTemplate
  000d2	48 89 45 48	 mov	 QWORD PTR nullTmp$[rbp], rax

; 208  : 
; 209  : 	TypeInfo newInfo = {

  000d6	48 8b 85 90 01
	00 00		 mov	 rax, QWORD PTR name$[rbp]
  000dd	48 89 45 68	 mov	 QWORD PTR newInfo$[rbp], rax
  000e1	48 8b 85 98 01
	00 00		 mov	 rax, QWORD PTR size$[rbp]
  000e8	48 89 45 70	 mov	 QWORD PTR newInfo$[rbp+8], rax
  000ec	48 8b 45 48	 mov	 rax, QWORD PTR nullTmp$[rbp]
  000f0	48 89 45 78	 mov	 QWORD PTR newInfo$[rbp+16], rax

; 210  : 		name,
; 211  : 		size,
; 212  : 		nullTmp,
; 213  : 	};
; 214  : 
; 215  : 	TypeInfo* ptr = &testTypeBin[testTypeBinCurrentCount];

  000f4	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR testTypeBinCurrentCount
  000fa	48 6b c0 18	 imul	 rax, rax, 24
  000fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:testTypeBin
  00105	48 03 c8	 add	 rcx, rax
  00108	48 8b c1	 mov	 rax, rcx
  0010b	48 89 85 98 00
	00 00		 mov	 QWORD PTR ptr$[rbp], rax

; 216  : 	rawTranscribe(ptr, &newInfo, sizeof(TypeInfo));

  00112	41 b8 18 00 00
	00		 mov	 r8d, 24
  00118	48 8d 55 68	 lea	 rdx, QWORD PTR newInfo$[rbp]
  0011c	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR ptr$[rbp]
  00123	e8 00 00 00 00	 call	 rawTranscribe

; 217  : 	testTypeBinCurrentCount++;

  00128	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR testTypeBinCurrentCount
  0012e	ff c0		 inc	 eax
  00130	89 05 00 00 00
	00		 mov	 DWORD PTR testTypeBinCurrentCount, eax

; 218  : 	return ptr;

  00136	48 8b 85 98 00
	00 00		 mov	 rax, QWORD PTR ptr$[rbp]
$LN1@TypeInfo_G:

; 219  : }

  0013d	48 8b f8	 mov	 rdi, rax
  00140	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  00144	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:TypeInfo_GetNullable$rtcFrameData
  0014b	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00150	48 8b c7	 mov	 rax, rdi
  00153	48 8b 8d 68 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  0015a	48 33 cd	 xor	 rcx, rbp
  0015d	e8 00 00 00 00	 call	 __security_check_cookie
  00162	48 8d a5 78 01
	00 00		 lea	 rsp, QWORD PTR [rbp+376]
  00169	5f		 pop	 rdi
  0016a	5d		 pop	 rbp
  0016b	c3		 ret	 0
TypeInfo_GetNullable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tTypeInfo.c
;	COMDAT TypeInfo_Compare
_TEXT	SEGMENT
a$ = 224
b$ = 232
TypeInfo_Compare PROC					; COMDAT

; 136  : bool TypeInfo_Compare(TypeInfo* a, TypeInfo* b) {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__44D20BAF_tTypeInfo@c
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 137  : 	return defaultStringCompare(a->_name, b->_name);

  00024	48 8b 85 e8 00
	00 00		 mov	 rax, QWORD PTR b$[rbp]
  0002b	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0002e	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR a$[rbp]
  00035	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00038	e8 00 00 00 00	 call	 defaultStringCompare

; 138  : }

  0003d	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00044	5f		 pop	 rdi
  00045	5d		 pop	 rbp
  00046	c3		 ret	 0
TypeInfo_Compare ENDP
_TEXT	ENDS
END
