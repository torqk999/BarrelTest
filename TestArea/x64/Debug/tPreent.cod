; Listing generated by Microsoft (R) Optimizing Compiler Version 19.39.33523.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__9C67CA7D_tEnums@h DB 01H
__EAEE5CFA_tDefines@h DB 01H
__0ED14FEE_winpackagefamily@h DB 01H
__F92EF742_winapifamily@h DB 01H
__22E515EB_sdkddkver@h DB 01H
__FE09AF47_concurrencysal@h DB 01H
__C073CA79_sal@h DB 01H
__D6AFE870_vadefs@h DB 01H
__D63E96CF_vcruntime@h DB 01H
__514B86D7_excpt@h DB 01H
__9A7D38D9_stdarg@h DB 01H
__29F49F40_specstrings_undef@h DB 01H
__D0F42932_specstrings_strict@h DB 01H
__F00405FD_sdv_driverspecs@h DB 01H
__173E09CA_driverspecs@h DB 01H
__9A452361_specstrings@h DB 01H
__1B0272D9_corecrt@h DB 01H
__74484FB3_corecrt_wctype@h DB 01H
__1EC467ED_ctype@h DB 01H
__98517906_kernelspecs@h DB 01H
__D3497022_basetsd@h DB 01H
__61CC25A1_errno@h DB 01H
__3EADF068_vcruntime_string@h DB 01H
__E4C945B4_corecrt_memcpy_s@h DB 01H
__8EAFF484_corecrt_memory@h DB 01H
__6490AEC5_corecrt_wstring@h DB 01H
__E8295E1E_string@h DB 01H
__7FCB5136_guiddef@h DB 01H
__FF8A9E11_pshpack4@h DB 01H
__D5438902_poppack@h DB 01H
__FB07E2A3_pshpack2@h DB 01H
__F6906775_pshpack8@h DB 01H
__F9415CFA_pshpack1@h DB 01H
__E58C6F1C_apiset@h DB 01H
__A5C52262_ktmtypes@h DB 01H
__FBBA8F9D_winnt@h DB 01H
__A32D3D2C_minwindef@h DB 01H
__7D798299_windef@h DB 01H
__9AE108E9_apisetcconv@h DB 01H
__9CE53D2C_minwinbase@h DB 01H
__5D0AA210_apiquery2@h DB 01H
__4DD4E726_processenv@h DB 01H
__3575CC96_fileapi@h DB 01H
__8EA220E6_fileapifromapp@h DB 01H
__BF9B31FE_debugapi@h DB 01H
__C3AFE134_utilapiset@h DB 01H
__76F69E51_handleapi@h DB 01H
__7E63D784_errhandlingapi@h DB 01H
__FFA7003C_fibersapi@h DB 01H
__8971CECF_namedpipeapi@h DB 01H
__46C9D8A6_profileapi@h DB 01H
__98D4F0A3_heapapi@h DB 01H
__50EF2A88_ioapiset@h DB 01H
__92EA1464_synchapi@h DB 01H
__A53D8AED_interlockedapi@h DB 01H
__B506CAAF_processthreadsapi@h DB 01H
__FF735694_sysinfoapi@h DB 01H
__29589789_memoryapi@h DB 01H
__E9C7A663_enclaveapi@h DB 01H
__D035F9F7_threadpoollegacyapiset@h DB 01H
__C899130C_threadpoolapiset@h DB 01H
__E0441EE7_jobapi@h DB 01H
__CEF86838_jobapi2@h DB 01H
__35AC6B9A_wow64apiset@h DB 01H
__C8AE41A5_libloaderapi@h DB 01H
__CC9E232D_securitybaseapi@h DB 01H
__C9D0C9B8_namespaceapi@h DB 01H
__30FF9CAD_systemtopologyapi@h DB 01H
__4D358795_processtopologyapi@h DB 01H
__40446D10_securityappcontainer@h DB 01H
__3A952EDF_realtimeapiset@h DB 01H
__F4865F4B_winerror@h DB 01H
__53C1BD93_timezoneapi@h DB 01H
__1FFBEDBF_winbase@h DB 01H
__43D3FA34_wingdi@h DB 01H
__D24A7391_tvout@h DB 01H
__7713A6C8_winuser@h DB 01H
__0B345F71_datetimeapi@h DB 01H
__9AC6960C_winnls@h DB 01H
__973A40A8_stringapiset@h DB 01H
__CC46FEE2_wincontypes@h DB 01H
__97D70BE1_consoleapi@h DB 01H
__27EC5E18_consoleapi2@h DB 01H
__262E342F_consoleapi3@h DB 01H
__641DCD70_wincon@h DB 01H
__5A96C7A7_verrsrc@h DB 01H
__B69C6FF2_winver@h DB 01H
__7AEB8C37_reason@h DB 01H
__59F1A8A9_winreg@h DB 01H
__EE0E2B7F_wnnc@h DB 01H
__DCDB7054_winnetwk@h DB 01H
__EDC72EEB_cderr@h DB 01H
__95F9199D_dde@h DB 01H
__66427627_ddeml@h DB 01H
__957C29A0_dlgs@h DB 01H
__12EA15AF_lzexpand@h DB 01H
__62131F15_mmsyscom@h DB 01H
__47E68D49_mciapi@h DB 01H
__5D7DD356_mmiscapi@h DB 01H
__7223D2EF_mmiscapi2@h DB 01H
__A330DBB3_playsoundapi@h DB 01H
__601B366F_mmeapi@h DB 01H
__1134ADD5_timeapi@h DB 01H
__93F2265A_joystickapi@h DB 01H
__DF6EB4E3_mmsystem@h DB 01H
__BD641FCB_nb30@h DB 01H
__DF8704F0_rpcdcep@h DB 01H
__5C6CA7BB_rpcdce@h DB 01H
__853533C4_rpcnsi@h DB 01H
__2D2406C3_rpcnterr@h DB 01H
__64521D71_rpcasync@h DB 01H
__AADCBA08_rpc@h DB 01H
__19E26CFF_shellapi@h DB 01H
__1E9F31D3_winperf@h DB 01H
__832A4112_inaddr@h DB 01H
__32C6F875_winsock@h DB 01H
__7953A3F8_bcrypt@h DB 01H
__E4169492_ncrypt@h DB 01H
__AF3DDDC3_dpapi@h DB 01H
__D1E23BF2_wincrypt@h DB 01H
__82AB4779_winefs@h DB 01H
__1FE431C9_rpcnsip@h DB 01H
__2B741F2D_rpcsal@h DB 01H
__92623256_rpcndr@h DB 01H
__9C18532E_wtypesbase@h DB 01H
__EA2E1D6D_wtypes@h DB 01H
__7DDD9F45_winioctl@h DB 01H
__E550A843_winsmcrd@h DB 01H
__9809C1BA_winscard@h DB 01H
__EA174FA4_prsht@h DB 01H
__0E1BD114_winspool@h DB 01H
__45DED006_corecrt_malloc@h DB 01H
__13F5961F_stddef@h DB 01H
__FD6DBD68_corecrt_search@h DB 01H
__E2E33A61_corecrt_wstdlib@h DB 01H
__10D4A829_limits@h DB 01H
__6E5ACABA_stdlib@h DB 01H
__30B1AFDA_unknwnbase@h DB 01H
__328C1996_objidlbase@h DB 01H
__C4E06B6A_cguid@h DB 01H
__434718C5_combaseapi@h DB 01H
__DE6FDEF1_unknwn@h DB 01H
__CCE0BACC_objidl@h DB 01H
__8C7011E5_oaidl@h DB 01H
__2E0B7863_propidlbase@h DB 01H
__BF4CF2EC_coml2api@h DB 01H
__6D897344_oleidl@h DB 01H
__1129FC2C_servprov@h DB 01H
__757952E4_msxml@h DB 01H
__B1191D53_urlmon@h DB 01H
__404D1A47_propidl@h DB 01H
__A1C63593_objbase@h DB 01H
__C1B0A9CB_oleauto@h DB 01H
__24EAF61F_ole2@h DB 01H
__2B1843DA_commdlg@h DB 01H
__81DDEDE3_stralign@h DB 01H
__2134D1B4_winsvc@h DB 01H
__11C07376_mcx@h DB 01H
__577CE3E7_ime_cmodes@h DB 01H
__1E72C31E_imm@h DB 01H
__63AA7AF5_Windows@h DB 01H
__4EC676C0_tModules@h DB 01H
__AFB9CF29_tPreent@h DB 01H
__386B16A1_tPreent@c DB 01H
msvcjmc	ENDS
PUBLIC	strLenSafe
PUBLIC	pootChar
PUBLIC	pootStr
PUBLIC	integerConvert
PUBLIC	strToInt
PUBLIC	numConvert
PUBLIC	Preent
PUBLIC	GeetCount
PUBLIC	Geet
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BF@CAJJEMJD@?6?$FLNULL?5PARAM?5ERROR?$FN?6@ ; `string'
PUBLIC	__real@0000000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@43e0000000000000
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_GetStdHandle:PROC
EXTRN	__imp_ReadConsoleA:PROC
EXTRN	__imp_WriteConsoleA:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_BSS	SEGMENT
PREENT_BUFFER DB 040H DUP (?)
?iBuffer@?1??integerConvert@@9@9 DB 032H DUP (?)	; `integerConvert'::`2'::iBuffer
	ALIGN	4

?Buffer@?1??numConvert@@9@9 DB 032H DUP (?)		; `numConvert'::`2'::Buffer
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$strLenSafe DD imagerel $LN7
	DD	imagerel $LN7+107
	DD	imagerel $unwind$strLenSafe
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pootChar DD imagerel $LN3
	DD	imagerel $LN3+92
	DD	imagerel $unwind$pootChar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pootStr DD imagerel $LN4
	DD	imagerel $LN4+114
	DD	imagerel $unwind$pootStr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$integerConvert DD imagerel $LN6
	DD	imagerel $LN6+156
	DD	imagerel $unwind$integerConvert
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$strToInt DD imagerel $LN11
	DD	imagerel $LN11+255
	DD	imagerel $unwind$strToInt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$numConvert DD imagerel $LN53
	DD	imagerel $LN53+1632
	DD	imagerel $unwind$numConvert
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Preent DD imagerel $LN28
	DD	imagerel $LN28+716
	DD	imagerel $unwind$Preent
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GeetCount DD imagerel $LN3
	DD	imagerel $LN3+97
	DD	imagerel $unwind$GeetCount
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Geet DD	imagerel $LN3
	DD	imagerel $LN3+117
	DD	imagerel $unwind$Geet
pdata	ENDS
;	COMDAT __real@43e0000000000000
CONST	SEGMENT
__real@43e0000000000000 DQ 043e0000000000000r	; 9.22337e+18
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BF@CAJJEMJD@?6?$FLNULL?5PARAM?5ERROR?$FN?6@
CONST	SEGMENT
??_C@_0BF@CAJJEMJD@?6?$FLNULL?5PARAM?5ERROR?$FN?6@ DB 0aH, '[NULL PARAM E'
	DB	'RROR]', 0aH, 00H				; `string'
CONST	ENDS
_DATA	SEGMENT
?Representation@?1??integerConvert@@9@9 DB '0123456789ABCDEF', 00H ; `integerConvert'::`2'::Representation
	ORG $+7
?Representation@?1??numConvert@@9@9 DB '0123456789ABCDEF', 00H ; `numConvert'::`2'::Representation
	ORG $+7
?ParamSymbol@?1??numConvert@@9@9 DB 'csLIxlObhiofd', 00H ; `numConvert'::`2'::ParamSymbol
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	02aH
	DB	05cH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Geet DD	025053119H
	DD	010a230fH
	DD	070030021H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	0f8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
Geet$rtcName$0 DB 063H
	DB	06fH
	DB	075H
	DB	06eH
	DB	074H
	DB	00H
	ORG $+10
Geet$rtcVarDesc DD 024H
	DD	04H
	DQ	FLAT:Geet$rtcName$0
	ORG $+48
Geet$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:Geet$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GeetCount DD 035051301H
	DD	010e3313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Preent DD 025061901H
	DD	01142319H
	DD	0700d003aH
	DD	0500b600cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$numConvert DD 025051301H
	DD	010e2313H
	DD	070070049H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$strToInt DD 025051301H
	DD	010e2313H
	DD	070070031H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$integerConvert DD 025051601H
	DD	01112316H
	DD	0700a0021H
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pootStr DD 035051d01H
	DD	0118331dH
	DD	070110023H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pootChar DD 035051c01H
	DD	0117331cH
	DD	07010001fH
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$strLenSafe DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	c2 00 00	 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tPreent.c
;	COMDAT Geet
_TEXT	SEGMENT
count$ = 4
__$ArrayPad$ = 216
Geet	PROC						; COMDAT

; 311  : {

$LN3:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00014	b9 0a 00 00 00	 mov	 ecx, 10
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00027	48 33 c5	 xor	 rax, rbp
  0002a	48 89 85 d8 00
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__386B16A1_tPreent@c
  00038	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 312  : 	unsigned int count;
; 313  : 	return GeetCount(&count);

  0003d	48 8d 4d 04	 lea	 rcx, QWORD PTR count$[rbp]
  00041	e8 00 00 00 00	 call	 GeetCount

; 314  : }

  00046	48 8b f8	 mov	 rdi, rax
  00049	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Geet$rtcFrameData
  00054	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00059	48 8b c7	 mov	 rax, rdi
  0005c	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00063	48 33 cd	 xor	 rcx, rbp
  00066	e8 00 00 00 00	 call	 __security_check_cookie
  0006b	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00072	5f		 pop	 rdi
  00073	5d		 pop	 rbp
  00074	c3		 ret	 0
Geet	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tPreent.c
;	COMDAT GeetCount
_TEXT	SEGMENT
count$ = 224
GeetCount PROC						; COMDAT

; 302  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0000e	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__386B16A1_tPreent@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 303  : 	ReadConsoleA(GetStdHandle(STD_INPUT_HANDLE), PREENT_BUFFER, MAX_CONSOLE_BUFFER, count, NULL);

  0001f	b9 f6 ff ff ff	 mov	 ecx, -10		; fffffff6H
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle
  0002a	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00033	4c 8b 8d e0 00
	00 00		 mov	 r9, QWORD PTR count$[rbp]
  0003a	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PREENT_BUFFER
  00047	48 8b c8	 mov	 rcx, rax
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReadConsoleA

; 304  : 
; 305  : 	return PREENT_BUFFER;

  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PREENT_BUFFER

; 306  : 	//*count = *count <= 1 ? 0 : *count - 1;
; 307  : 	//PREENT_BUFFER[*count - 1] = '\0';
; 308  : }

  00057	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0005e	5f		 pop	 rdi
  0005f	5d		 pop	 rbp
  00060	c3		 ret	 0
GeetCount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tPreent.c
;	COMDAT Preent
_TEXT	SEGMENT
startIndex$ = 4
workingIndex$ = 40
output$ = 72
written$ = 100
i$1 = 132
$T2 = 360
$T3 = 400
tv132 = 420
string$ = 464
head$ = 472
Preent	PROC						; COMDAT

; 236  : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	48 81 ec d0 01
	00 00		 sub	 rsp, 464		; 000001d0H
  00014	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__386B16A1_tPreent@c
  00020	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 237  : 	unsigned int startIndex = 0;

  00025	c7 45 04 00 00
	00 00		 mov	 DWORD PTR startIndex$[rbp], 0

; 238  : 	char* workingIndex = PREENT_BUFFER;

  0002c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PREENT_BUFFER
  00033	48 89 45 28	 mov	 QWORD PTR workingIndex$[rbp], rax

; 239  : 
; 240  : 	//void* ptr = head;
; 241  : 
; 242  : 	HANDLE output = GetStdHandle(STD_OUTPUT_HANDLE);

  00037	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle
  00042	48 89 45 48	 mov	 QWORD PTR output$[rbp], rax

; 243  : 	DWORD written = 0;

  00046	c7 45 64 00 00
	00 00		 mov	 DWORD PTR written$[rbp], 0

; 244  : 
; 245  : 	for (int i = 0; i < MAX_CONSOLE_BUFFER; i++)

  0004d	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR i$1[rbp], 0
  00057	eb 0e		 jmp	 SHORT $LN4@Preent
$LN2@Preent:
  00059	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$1[rbp]
  0005f	ff c0		 inc	 eax
  00061	89 85 84 00 00
	00		 mov	 DWORD PTR i$1[rbp], eax
$LN4@Preent:
  00067	83 bd 84 00 00
	00 40		 cmp	 DWORD PTR i$1[rbp], 64	; 00000040H
  0006e	0f 8d f9 01 00
	00		 jge	 $LN3@Preent

; 246  : 	{
; 247  : 		PREENT_BUFFER[i] = string[i];

  00074	48 63 85 84 00
	00 00		 movsxd	 rax, DWORD PTR i$1[rbp]
  0007b	48 63 8d 84 00
	00 00		 movsxd	 rcx, DWORD PTR i$1[rbp]
  00082	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PREENT_BUFFER
  00089	4c 8b 85 d0 01
	00 00		 mov	 r8, QWORD PTR string$[rbp]
  00090	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00095	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 248  : 
; 249  : 		if (string[i] == '\0') // end of PREENT STREEM

  00098	48 63 85 84 00
	00 00		 movsxd	 rax, DWORD PTR i$1[rbp]
  0009f	48 8b 8d d0 01
	00 00		 mov	 rcx, QWORD PTR string$[rbp]
  000a6	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000aa	85 c0		 test	 eax, eax
  000ac	75 18		 jne	 SHORT $LN7@Preent

; 250  : 		{
; 251  : 			pootStr(workingIndex, output, written);

  000ae	44 8b 45 64	 mov	 r8d, DWORD PTR written$[rbp]
  000b2	48 8b 55 48	 mov	 rdx, QWORD PTR output$[rbp]
  000b6	48 8b 4d 28	 mov	 rcx, QWORD PTR workingIndex$[rbp]
  000ba	e8 00 00 00 00	 call	 pootStr

; 252  : 			return NULL;

  000bf	33 c0		 xor	 eax, eax
  000c1	e9 bd 01 00 00	 jmp	 $LN1@Preent
$LN7@Preent:

; 253  : 		}
; 254  : 
; 255  : 		if (string[i] == '%') // next PREENT PRAM

  000c6	48 63 85 84 00
	00 00		 movsxd	 rax, DWORD PTR i$1[rbp]
  000cd	48 8b 8d d0 01
	00 00		 mov	 rcx, QWORD PTR string$[rbp]
  000d4	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000d8	83 f8 25	 cmp	 eax, 37			; 00000025H
  000db	0f 85 87 01 00
	00		 jne	 $LN8@Preent

; 256  : 		{
; 257  : 			PREENT_BUFFER[i] = '\0';

  000e1	48 63 85 84 00
	00 00		 movsxd	 rax, DWORD PTR i$1[rbp]
  000e8	48 89 85 68 01
	00 00		 mov	 QWORD PTR $T2[rbp], rax
  000ef	48 83 bd 68 01
	00 00 40	 cmp	 QWORD PTR $T2[rbp], 64	; 00000040H
  000f7	73 02		 jae	 SHORT $LN25@Preent
  000f9	eb 05		 jmp	 SHORT $LN26@Preent
$LN25@Preent:
  000fb	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN26@Preent:
  00100	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PREENT_BUFFER
  00107	48 8b 8d 68 01
	00 00		 mov	 rcx, QWORD PTR $T2[rbp]
  0010e	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 258  : 			pootStr(workingIndex, output, written);

  00112	44 8b 45 64	 mov	 r8d, DWORD PTR written$[rbp]
  00116	48 8b 55 48	 mov	 rdx, QWORD PTR output$[rbp]
  0011a	48 8b 4d 28	 mov	 rcx, QWORD PTR workingIndex$[rbp]
  0011e	e8 00 00 00 00	 call	 pootStr

; 259  : 			workingIndex = &PREENT_BUFFER[i + 1];

  00123	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR i$1[rbp]
  00129	ff c0		 inc	 eax
  0012b	48 98		 cdqe
  0012d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PREENT_BUFFER
  00134	48 03 c8	 add	 rcx, rax
  00137	48 8b c1	 mov	 rax, rcx
  0013a	48 89 45 28	 mov	 QWORD PTR workingIndex$[rbp], rax

; 260  : 
; 261  : 			switch (head[0]._type)

  0013e	b8 10 00 00 00	 mov	 eax, 16
  00143	48 6b c0 00	 imul	 rax, rax, 0
  00147	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR head$[rbp]
  0014e	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00151	89 85 a4 01 00
	00		 mov	 DWORD PTR tv132[rbp], eax
  00157	8b 85 a4 01 00
	00		 mov	 eax, DWORD PTR tv132[rbp]
  0015d	83 c0 02	 add	 eax, 2
  00160	89 85 a4 01 00
	00		 mov	 DWORD PTR tv132[rbp], eax
  00166	83 bd a4 01 00
	00 0e		 cmp	 DWORD PTR tv132[rbp], 14
  0016d	0f 87 f5 00 00
	00		 ja	 $LN23@Preent
  00173	48 63 85 a4 01
	00 00		 movsxd	 rax, DWORD PTR tv132[rbp]
  0017a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00181	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN27@Preent[rcx+rax*4]
  00188	48 03 c1	 add	 rax, rcx
  0018b	ff e0		 jmp	 rax
$LN9@Preent:

; 262  : 			{
; 263  : 			case __c:
; 264  : 				pootChar(*((char*)(head[0]._ptr)), output, written);

  0018d	b8 10 00 00 00	 mov	 eax, 16
  00192	48 6b c0 00	 imul	 rax, rax, 0
  00196	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR head$[rbp]
  0019d	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  001a2	44 8b 45 64	 mov	 r8d, DWORD PTR written$[rbp]
  001a6	48 8b 55 48	 mov	 rdx, QWORD PTR output$[rbp]
  001aa	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  001ad	e8 00 00 00 00	 call	 pootChar

; 265  : 				head++;

  001b2	48 8b 85 d8 01
	00 00		 mov	 rax, QWORD PTR head$[rbp]
  001b9	48 83 c0 10	 add	 rax, 16
  001bd	48 89 85 d8 01
	00 00		 mov	 QWORD PTR head$[rbp], rax

; 266  : 				break;

  001c4	e9 9f 00 00 00	 jmp	 $LN5@Preent
$LN10@Preent:

; 267  : 
; 268  : 			case __s:
; 269  : 				pootStr((char*)(head[0]._ptr), output, written);

  001c9	b8 10 00 00 00	 mov	 eax, 16
  001ce	48 6b c0 00	 imul	 rax, rax, 0
  001d2	44 8b 45 64	 mov	 r8d, DWORD PTR written$[rbp]
  001d6	48 8b 55 48	 mov	 rdx, QWORD PTR output$[rbp]
  001da	48 8b 8d d8 01
	00 00		 mov	 rcx, QWORD PTR head$[rbp]
  001e1	48 8b 4c 01 08	 mov	 rcx, QWORD PTR [rcx+rax+8]
  001e6	e8 00 00 00 00	 call	 pootStr

; 270  : 				head++;

  001eb	48 8b 85 d8 01
	00 00		 mov	 rax, QWORD PTR head$[rbp]
  001f2	48 83 c0 10	 add	 rax, 16
  001f6	48 89 85 d8 01
	00 00		 mov	 QWORD PTR head$[rbp], rax

; 271  : 				break;

  001fd	eb 69		 jmp	 SHORT $LN5@Preent
$LN11@Preent:
$LN12@Preent:
$LN13@Preent:
$LN14@Preent:
$LN15@Preent:
$LN16@Preent:
$LN17@Preent:
$LN18@Preent:
$LN19@Preent:
$LN20@Preent:
$LN21@Preent:

; 272  : 
; 273  : 			case __b:
; 274  : 			case __I:
; 275  : 			case __L:
; 276  : 			case __x:
; 277  : 			case __l:
; 278  : 			case __O:
; 279  : 			case __h:
; 280  : 			case __i:
; 281  : 			case __o:
; 282  : 			case __f:
; 283  : 			case __d:
; 284  : 				pootStr(numConvert(head[0]), output, written);

  001ff	b8 10 00 00 00	 mov	 eax, 16
  00204	48 6b c0 00	 imul	 rax, rax, 0
  00208	48 8d 8d 90 01
	00 00		 lea	 rcx, QWORD PTR $T3[rbp]
  0020f	48 8b 95 d8 01
	00 00		 mov	 rdx, QWORD PTR head$[rbp]
  00216	48 8b f9	 mov	 rdi, rcx
  00219	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  0021d	b9 10 00 00 00	 mov	 ecx, 16
  00222	f3 a4		 rep movsb
  00224	48 8d 8d 90 01
	00 00		 lea	 rcx, QWORD PTR $T3[rbp]
  0022b	e8 00 00 00 00	 call	 numConvert
  00230	44 8b 45 64	 mov	 r8d, DWORD PTR written$[rbp]
  00234	48 8b 55 48	 mov	 rdx, QWORD PTR output$[rbp]
  00238	48 8b c8	 mov	 rcx, rax
  0023b	e8 00 00 00 00	 call	 pootStr

; 285  : 				head++;

  00240	48 8b 85 d8 01
	00 00		 mov	 rax, QWORD PTR head$[rbp]
  00247	48 83 c0 10	 add	 rax, 16
  0024b	48 89 85 d8 01
	00 00		 mov	 QWORD PTR head$[rbp], rax

; 286  : 				break;

  00252	eb 14		 jmp	 SHORT $LN5@Preent
$LN22@Preent:

; 287  : 
; 288  : 			case NONE:
; 289  : 				pootStr("\n[NULL PARAM ERROR]\n", output, written);

  00254	44 8b 45 64	 mov	 r8d, DWORD PTR written$[rbp]
  00258	48 8b 55 48	 mov	 rdx, QWORD PTR output$[rbp]
  0025c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@CAJJEMJD@?6?$FLNULL?5PARAM?5ERROR?$FN?6@
  00263	e8 00 00 00 00	 call	 pootStr
$LN23@Preent:
$LN5@Preent:
$LN8@Preent:

; 290  : 				break;
; 291  : 
; 292  : 			default:
; 293  : 				break;
; 294  : 			}
; 295  : 		}
; 296  : 	}

  00268	e9 ec fd ff ff	 jmp	 $LN2@Preent
$LN3@Preent:

; 297  : 
; 298  : 	return &(string[MAX_CONSOLE_BUFFER]);

  0026d	b8 01 00 00 00	 mov	 eax, 1
  00272	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  00276	48 8b 8d d0 01
	00 00		 mov	 rcx, QWORD PTR string$[rbp]
  0027d	48 03 c8	 add	 rcx, rax
  00280	48 8b c1	 mov	 rax, rcx
$LN1@Preent:
$LN24@Preent:

; 299  : }

  00283	48 8d a5 b0 01
	00 00		 lea	 rsp, QWORD PTR [rbp+432]
  0028a	5f		 pop	 rdi
  0028b	5e		 pop	 rsi
  0028c	5d		 pop	 rbp
  0028d	c3		 ret	 0
  0028e	66 90		 npad	 2
$LN27@Preent:
  00290	00 00 00 00	 DD	 $LN22@Preent
  00294	00 00 00 00	 DD	 $LN23@Preent
  00298	00 00 00 00	 DD	 $LN9@Preent
  0029c	00 00 00 00	 DD	 $LN10@Preent
  002a0	00 00 00 00	 DD	 $LN13@Preent
  002a4	00 00 00 00	 DD	 $LN12@Preent
  002a8	00 00 00 00	 DD	 $LN14@Preent
  002ac	00 00 00 00	 DD	 $LN15@Preent
  002b0	00 00 00 00	 DD	 $LN16@Preent
  002b4	00 00 00 00	 DD	 $LN11@Preent
  002b8	00 00 00 00	 DD	 $LN17@Preent
  002bc	00 00 00 00	 DD	 $LN18@Preent
  002c0	00 00 00 00	 DD	 $LN19@Preent
  002c4	00 00 00 00	 DD	 $LN20@Preent
  002c8	00 00 00 00	 DD	 $LN21@Preent
Preent	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tPreent.c
;	COMDAT numConvert
_TEXT	SEGMENT
ptr$ = 8
isPositive$ = 68
isInt$ = 100
isFloat$ = 132
intCheck$ = 164
longCheck$ = 200
fVal$ = 232
iVal$ = 264
fRem$ = 296
base$ = 324
tv136 = 532
tv134 = 532
tv81 = 532
tv76 = 532
tv73 = 532
tv67 = 532
tv167 = 536
tv163 = 536
tv156 = 536
tv152 = 536
tv84 = 536
preem$ = 576
numConvert PROC						; COMDAT

; 102  : {

$LN53:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 48 02
	00 00		 sub	 rsp, 584		; 00000248H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__386B16A1_tPreent@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 103  : 	static char Representation[] = "0123456789ABCDEF";
; 104  : 	static char ParamSymbol[] = "csLIxlObhiofd";
; 105  : 	static char Buffer[MAX_NUM_BUFFER];
; 106  : 
; 107  : 	char* ptr = &Buffer[MAX_NUM_BUFFER - 1];

  0001f	b8 01 00 00 00	 mov	 eax, 1
  00024	48 6b c0 31	 imul	 rax, rax, 49		; 00000031H
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Buffer@?1??numConvert@@9@9
  0002f	48 03 c8	 add	 rcx, rax
  00032	48 8b c1	 mov	 rax, rcx
  00035	48 89 45 08	 mov	 QWORD PTR ptr$[rbp], rax

; 108  : 	*ptr = '\0';

  00039	48 8b 45 08	 mov	 rax, QWORD PTR ptr$[rbp]
  0003d	c6 00 00	 mov	 BYTE PTR [rax], 0

; 109  : 
; 110  : 	char next;
; 111  : 	int isPositive = 1;

  00040	c7 45 44 01 00
	00 00		 mov	 DWORD PTR isPositive$[rbp], 1

; 112  : 	bool isInt = false;

  00047	c7 45 64 00 00
	00 00		 mov	 DWORD PTR isInt$[rbp], 0

; 113  : 	bool isFloat = false;

  0004e	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR isFloat$[rbp], 0

; 114  : 
; 115  : 	int intCheck;
; 116  : 	long long longCheck;
; 117  : 
; 118  : 	double fVal = 0;

  00058	0f 57 c0	 xorps	 xmm0, xmm0
  0005b	f2 0f 11 85 e8
	00 00 00	 movsd	 QWORD PTR fVal$[rbp], xmm0

; 119  : 	unsigned long long iVal = 0;

  00063	48 c7 85 08 01
	00 00 00 00 00
	00		 mov	 QWORD PTR iVal$[rbp], 0

; 120  : 	unsigned long long fRem = 0;

  0006e	48 c7 85 28 01
	00 00 00 00 00
	00		 mov	 QWORD PTR fRem$[rbp], 0

; 121  : 	unsigned int base = 0;

  00079	c7 85 44 01 00
	00 00 00 00 00	 mov	 DWORD PTR base$[rbp], 0

; 122  : 
; 123  : 	switch (preem._type)

  00083	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR preem$[rbp]
  0008a	8b 00		 mov	 eax, DWORD PTR [rax]
  0008c	89 85 14 02 00
	00		 mov	 DWORD PTR tv67[rbp], eax
  00092	8b 85 14 02 00
	00		 mov	 eax, DWORD PTR tv67[rbp]
  00098	83 e8 02	 sub	 eax, 2
  0009b	89 85 14 02 00
	00		 mov	 DWORD PTR tv67[rbp], eax
  000a1	83 bd 14 02 00
	00 0a		 cmp	 DWORD PTR tv67[rbp], 10
  000a8	0f 87 03 03 00
	00		 ja	 $LN2@numConvert
  000ae	48 63 85 14 02
	00 00		 movsxd	 rax, DWORD PTR tv67[rbp]
  000b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000bc	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN52@numConvert[rcx+rax*4]
  000c3	48 03 c1	 add	 rax, rcx
  000c6	ff e0		 jmp	 rax
$LN16@numConvert:

; 124  : 	{
; 125  : 	case __b:
; 126  : 		base = 1;

  000c8	c7 85 44 01 00
	00 01 00 00 00	 mov	 DWORD PTR base$[rbp], 1

; 127  : 		iVal = *((unsigned long long*)(preem._ptr));

  000d2	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR preem$[rbp]
  000d9	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000dd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000e0	48 89 85 08 01
	00 00		 mov	 QWORD PTR iVal$[rbp], rax

; 128  : 		break;

  000e7	e9 c5 02 00 00	 jmp	 $LN2@numConvert
$LN17@numConvert:

; 129  : 
; 130  : 	case __I:
; 131  : 		intCheck = *((int*)(preem._ptr));

  000ec	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR preem$[rbp]
  000f3	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000f7	8b 00		 mov	 eax, DWORD PTR [rax]
  000f9	89 85 a4 00 00
	00		 mov	 DWORD PTR intCheck$[rbp], eax

; 132  : 		isPositive = intCheck >= 0;

  000ff	83 bd a4 00 00
	00 00		 cmp	 DWORD PTR intCheck$[rbp], 0
  00106	7c 0c		 jl	 SHORT $LN34@numConvert
  00108	c7 85 14 02 00
	00 01 00 00 00	 mov	 DWORD PTR tv73[rbp], 1
  00112	eb 0a		 jmp	 SHORT $LN35@numConvert
$LN34@numConvert:
  00114	c7 85 14 02 00
	00 00 00 00 00	 mov	 DWORD PTR tv73[rbp], 0
$LN35@numConvert:
  0011e	8b 85 14 02 00
	00		 mov	 eax, DWORD PTR tv73[rbp]
  00124	89 45 44	 mov	 DWORD PTR isPositive$[rbp], eax

; 133  : 		iVal = isPositive ? intCheck : -intCheck;

  00127	83 7d 44 00	 cmp	 DWORD PTR isPositive$[rbp], 0
  0012b	74 0e		 je	 SHORT $LN36@numConvert
  0012d	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR intCheck$[rbp]
  00133	89 85 14 02 00
	00		 mov	 DWORD PTR tv76[rbp], eax
  00139	eb 0e		 jmp	 SHORT $LN37@numConvert
$LN36@numConvert:
  0013b	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR intCheck$[rbp]
  00141	f7 d8		 neg	 eax
  00143	89 85 14 02 00
	00		 mov	 DWORD PTR tv76[rbp], eax
$LN37@numConvert:
  00149	48 63 85 14 02
	00 00		 movsxd	 rax, DWORD PTR tv76[rbp]
  00150	48 89 85 08 01
	00 00		 mov	 QWORD PTR iVal$[rbp], rax

; 134  : 		base = 10;

  00157	c7 85 44 01 00
	00 0a 00 00 00	 mov	 DWORD PTR base$[rbp], 10

; 135  : 		goto IsInt;

  00161	e9 07 01 00 00	 jmp	 $IsInt$54
$LN18@numConvert:

; 136  : 	case __L:
; 137  : 		longCheck = *((long long*)(preem._ptr));

  00166	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR preem$[rbp]
  0016d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00171	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00174	48 89 85 c8 00
	00 00		 mov	 QWORD PTR longCheck$[rbp], rax

; 138  : 		isPositive = longCheck >= 0;

  0017b	48 83 bd c8 00
	00 00 00	 cmp	 QWORD PTR longCheck$[rbp], 0
  00183	7c 0c		 jl	 SHORT $LN38@numConvert
  00185	c7 85 14 02 00
	00 01 00 00 00	 mov	 DWORD PTR tv81[rbp], 1
  0018f	eb 0a		 jmp	 SHORT $LN39@numConvert
$LN38@numConvert:
  00191	c7 85 14 02 00
	00 00 00 00 00	 mov	 DWORD PTR tv81[rbp], 0
$LN39@numConvert:
  0019b	8b 85 14 02 00
	00		 mov	 eax, DWORD PTR tv81[rbp]
  001a1	89 45 44	 mov	 DWORD PTR isPositive$[rbp], eax

; 139  : 		iVal = isPositive ? longCheck : -longCheck;

  001a4	83 7d 44 00	 cmp	 DWORD PTR isPositive$[rbp], 0
  001a8	74 10		 je	 SHORT $LN40@numConvert
  001aa	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR longCheck$[rbp]
  001b1	48 89 85 18 02
	00 00		 mov	 QWORD PTR tv84[rbp], rax
  001b8	eb 11		 jmp	 SHORT $LN41@numConvert
$LN40@numConvert:
  001ba	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR longCheck$[rbp]
  001c1	48 f7 d8	 neg	 rax
  001c4	48 89 85 18 02
	00 00		 mov	 QWORD PTR tv84[rbp], rax
$LN41@numConvert:
  001cb	48 8b 85 18 02
	00 00		 mov	 rax, QWORD PTR tv84[rbp]
  001d2	48 89 85 08 01
	00 00		 mov	 QWORD PTR iVal$[rbp], rax

; 140  : 		base = 10;

  001d9	c7 85 44 01 00
	00 0a 00 00 00	 mov	 DWORD PTR base$[rbp], 10

; 141  : 		goto IsInt;

  001e3	e9 85 00 00 00	 jmp	 $IsInt$54
$LN19@numConvert:

; 142  : 
; 143  : 	case __x:
; 144  : 		base += 6;

  001e8	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR base$[rbp]
  001ee	83 c0 06	 add	 eax, 6
  001f1	89 85 44 01 00
	00		 mov	 DWORD PTR base$[rbp], eax
$LN20@numConvert:

; 145  : 	case __l:
; 146  : 		base += 2;

  001f7	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR base$[rbp]
  001fd	83 c0 02	 add	 eax, 2
  00200	89 85 44 01 00
	00		 mov	 DWORD PTR base$[rbp], eax
$LN21@numConvert:

; 147  : 	case __O:
; 148  : 		base += 8;

  00206	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR base$[rbp]
  0020c	83 c0 08	 add	 eax, 8
  0020f	89 85 44 01 00
	00		 mov	 DWORD PTR base$[rbp], eax

; 149  : 		iVal = *((unsigned long long*)(preem._ptr));

  00215	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR preem$[rbp]
  0021c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00220	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00223	48 89 85 08 01
	00 00		 mov	 QWORD PTR iVal$[rbp], rax

; 150  : 		goto IsInt;

  0022a	eb 41		 jmp	 SHORT $IsInt$54
$LN22@numConvert:

; 151  : 
; 152  : 	case __h:
; 153  : 		base += 6;

  0022c	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR base$[rbp]
  00232	83 c0 06	 add	 eax, 6
  00235	89 85 44 01 00
	00		 mov	 DWORD PTR base$[rbp], eax
$LN23@numConvert:

; 154  : 	case __i:
; 155  : 		base += 2;

  0023b	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR base$[rbp]
  00241	83 c0 02	 add	 eax, 2
  00244	89 85 44 01 00
	00		 mov	 DWORD PTR base$[rbp], eax
$LN24@numConvert:

; 156  : 	case __o:
; 157  : 		base += 8;

  0024a	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR base$[rbp]
  00250	83 c0 08	 add	 eax, 8
  00253	89 85 44 01 00
	00		 mov	 DWORD PTR base$[rbp], eax

; 158  : 		iVal = *((unsigned int*)(preem._ptr));

  00259	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR preem$[rbp]
  00260	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00264	8b 00		 mov	 eax, DWORD PTR [rax]
  00266	48 89 85 08 01
	00 00		 mov	 QWORD PTR iVal$[rbp], rax
$IsInt$54:

; 159  : 
; 160  : 	IsInt:
; 161  : 		isInt = true;

  0026d	c7 45 64 01 00
	00 00		 mov	 DWORD PTR isInt$[rbp], 1

; 162  : 		break;

  00274	e9 38 01 00 00	 jmp	 $LN2@numConvert
$LN25@numConvert:

; 163  : 
; 164  : 	case __f:
; 165  : 		fVal = *((float*)(preem._ptr));

  00279	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR preem$[rbp]
  00280	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00284	f3 0f 5a 00	 cvtss2sd xmm0, DWORD PTR [rax]
  00288	f2 0f 11 85 e8
	00 00 00	 movsd	 QWORD PTR fVal$[rbp], xmm0

; 166  : 		goto IsFloat;

  00290	eb 17		 jmp	 SHORT $IsFloat$55
$LN26@numConvert:

; 167  : 	case __d:
; 168  : 		fVal = *((double*)(preem._ptr));

  00292	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR preem$[rbp]
  00299	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0029d	f2 0f 10 00	 movsd	 xmm0, QWORD PTR [rax]
  002a1	f2 0f 11 85 e8
	00 00 00	 movsd	 QWORD PTR fVal$[rbp], xmm0
$IsFloat$55:

; 169  : 	IsFloat:
; 170  : 		isPositive = fVal >= 0;

  002a9	f2 0f 10 85 e8
	00 00 00	 movsd	 xmm0, QWORD PTR fVal$[rbp]
  002b1	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  002b9	72 0c		 jb	 SHORT $LN42@numConvert
  002bb	c7 85 14 02 00
	00 01 00 00 00	 mov	 DWORD PTR tv134[rbp], 1
  002c5	eb 0a		 jmp	 SHORT $LN43@numConvert
$LN42@numConvert:
  002c7	c7 85 14 02 00
	00 00 00 00 00	 mov	 DWORD PTR tv134[rbp], 0
$LN43@numConvert:
  002d1	8b 85 14 02 00
	00		 mov	 eax, DWORD PTR tv134[rbp]
  002d7	89 45 44	 mov	 DWORD PTR isPositive$[rbp], eax

; 171  : 		fVal *= isPositive ? 1 : -1;

  002da	83 7d 44 00	 cmp	 DWORD PTR isPositive$[rbp], 0
  002de	74 0c		 je	 SHORT $LN44@numConvert
  002e0	c7 85 14 02 00
	00 01 00 00 00	 mov	 DWORD PTR tv136[rbp], 1
  002ea	eb 0a		 jmp	 SHORT $LN45@numConvert
$LN44@numConvert:
  002ec	c7 85 14 02 00
	00 ff ff ff ff	 mov	 DWORD PTR tv136[rbp], -1
$LN45@numConvert:
  002f6	f2 0f 2a 85 14
	02 00 00	 cvtsi2sd xmm0, DWORD PTR tv136[rbp]
  002fe	f2 0f 10 8d e8
	00 00 00	 movsd	 xmm1, QWORD PTR fVal$[rbp]
  00306	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  0030a	0f 28 c1	 movaps	 xmm0, xmm1
  0030d	f2 0f 11 85 e8
	00 00 00	 movsd	 QWORD PTR fVal$[rbp], xmm0

; 172  : 		iVal = fVal;

  00315	33 c0		 xor	 eax, eax
  00317	f2 0f 10 85 e8
	00 00 00	 movsd	 xmm0, QWORD PTR fVal$[rbp]
  0031f	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@43e0000000000000
  00327	72 1f		 jb	 SHORT $LN51@numConvert
  00329	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@43e0000000000000
  00331	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@43e0000000000000
  00339	73 0d		 jae	 SHORT $LN51@numConvert
  0033b	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00345	48 03 c1	 add	 rax, rcx
$LN51@numConvert:
  00348	f2 48 0f 2c c8	 cvttsd2si rcx, xmm0
  0034d	48 03 c8	 add	 rcx, rax
  00350	48 8b c1	 mov	 rax, rcx
  00353	48 89 85 08 01
	00 00		 mov	 QWORD PTR iVal$[rbp], rax

; 173  : 		fVal -= iVal;

  0035a	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR iVal$[rbp]
  00361	48 85 c0	 test	 rax, rax
  00364	7c 07		 jl	 SHORT $LN49@numConvert
  00366	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  0036b	eb 19		 jmp	 SHORT $LN50@numConvert
$LN49@numConvert:
  0036d	48 8b c8	 mov	 rcx, rax
  00370	48 d1 e9	 shr	 rcx, 1
  00373	48 83 e0 01	 and	 rax, 1
  00377	48 0b c8	 or	 rcx, rax
  0037a	f2 48 0f 2a c9	 cvtsi2sd xmm1, rcx
  0037f	f2 0f 58 c9	 addsd	 xmm1, xmm1
  00383	0f 28 c1	 movaps	 xmm0, xmm1
$LN50@numConvert:
  00386	f2 0f 10 8d e8
	00 00 00	 movsd	 xmm1, QWORD PTR fVal$[rbp]
  0038e	f2 0f 5c c8	 subsd	 xmm1, xmm0
  00392	0f 28 c1	 movaps	 xmm0, xmm1
  00395	f2 0f 11 85 e8
	00 00 00	 movsd	 QWORD PTR fVal$[rbp], xmm0

; 174  : 		base = 10;

  0039d	c7 85 44 01 00
	00 0a 00 00 00	 mov	 DWORD PTR base$[rbp], 10

; 175  : 		isFloat = true;

  003a7	c7 85 84 00 00
	00 01 00 00 00	 mov	 DWORD PTR isFloat$[rbp], 1
$LN2@numConvert:

; 176  : 	}
; 177  : 
; 178  : 	if (isFloat) // decimal section

  003b1	83 bd 84 00 00
	00 00		 cmp	 DWORD PTR isFloat$[rbp], 0
  003b8	0f 84 3e 01 00
	00		 je	 $LN27@numConvert

; 179  : 	{
; 180  : 		if (fVal > 0)

  003be	f2 0f 10 85 e8
	00 00 00	 movsd	 xmm0, QWORD PTR fVal$[rbp]
  003c6	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  003ce	0f 86 28 01 00
	00		 jbe	 $LN28@numConvert
$LN6@numConvert:

; 181  : 		{
; 182  : 			do
; 183  : 			{
; 184  : 				fVal *= 10;

  003d4	f2 0f 10 85 e8
	00 00 00	 movsd	 xmm0, QWORD PTR fVal$[rbp]
  003dc	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4024000000000000
  003e4	f2 0f 11 85 e8
	00 00 00	 movsd	 QWORD PTR fVal$[rbp], xmm0

; 185  : 				fRem = fVal;

  003ec	33 c0		 xor	 eax, eax
  003ee	f2 0f 10 85 e8
	00 00 00	 movsd	 xmm0, QWORD PTR fVal$[rbp]
  003f6	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@43e0000000000000
  003fe	72 1f		 jb	 SHORT $LN48@numConvert
  00400	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@43e0000000000000
  00408	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@43e0000000000000
  00410	73 0d		 jae	 SHORT $LN48@numConvert
  00412	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  0041c	48 03 c1	 add	 rax, rcx
$LN48@numConvert:
  0041f	f2 48 0f 2c c8	 cvttsd2si rcx, xmm0
  00424	48 03 c8	 add	 rcx, rax
  00427	48 8b c1	 mov	 rax, rcx
  0042a	48 89 85 28 01
	00 00		 mov	 QWORD PTR fRem$[rbp], rax

; 186  : 			} while (fVal - (double)fRem > 0);

  00431	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR fRem$[rbp]
  00438	48 85 c0	 test	 rax, rax
  0043b	7c 07		 jl	 SHORT $LN46@numConvert
  0043d	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  00442	eb 19		 jmp	 SHORT $LN47@numConvert
$LN46@numConvert:
  00444	48 8b c8	 mov	 rcx, rax
  00447	48 d1 e9	 shr	 rcx, 1
  0044a	48 83 e0 01	 and	 rax, 1
  0044e	48 0b c8	 or	 rcx, rax
  00451	f2 48 0f 2a c9	 cvtsi2sd xmm1, rcx
  00456	f2 0f 58 c9	 addsd	 xmm1, xmm1
  0045a	0f 28 c1	 movaps	 xmm0, xmm1
$LN47@numConvert:
  0045d	f2 0f 10 8d e8
	00 00 00	 movsd	 xmm1, QWORD PTR fVal$[rbp]
  00465	f2 0f 5c c8	 subsd	 xmm1, xmm0
  00469	0f 28 c1	 movaps	 xmm0, xmm1
  0046c	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  00474	0f 87 5a ff ff
	ff		 ja	 $LN6@numConvert
$LN9@numConvert:

; 187  : 
; 188  : 			do
; 189  : 			{
; 190  : 				ptr -= 1;

  0047a	48 8b 45 08	 mov	 rax, QWORD PTR ptr$[rbp]
  0047e	48 ff c8	 dec	 rax
  00481	48 89 45 08	 mov	 QWORD PTR ptr$[rbp], rax

; 191  : 				*ptr = Representation[fRem % base];

  00485	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR base$[rbp]
  0048b	48 89 85 18 02
	00 00		 mov	 QWORD PTR tv152[rbp], rax
  00492	33 d2		 xor	 edx, edx
  00494	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR fRem$[rbp]
  0049b	48 8b 8d 18 02
	00 00		 mov	 rcx, QWORD PTR tv152[rbp]
  004a2	48 f7 f1	 div	 rcx
  004a5	48 8b c2	 mov	 rax, rdx
  004a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Representation@?1??numConvert@@9@9
  004af	48 8b 55 08	 mov	 rdx, QWORD PTR ptr$[rbp]
  004b3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004b7	88 02		 mov	 BYTE PTR [rdx], al

; 192  : 				fRem /= base;

  004b9	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR base$[rbp]
  004bf	48 89 85 18 02
	00 00		 mov	 QWORD PTR tv156[rbp], rax
  004c6	33 d2		 xor	 edx, edx
  004c8	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR fRem$[rbp]
  004cf	48 8b 8d 18 02
	00 00		 mov	 rcx, QWORD PTR tv156[rbp]
  004d6	48 f7 f1	 div	 rcx
  004d9	48 89 85 28 01
	00 00		 mov	 QWORD PTR fRem$[rbp], rax

; 193  : 
; 194  : 			} while (fRem != 0);

  004e0	48 83 bd 28 01
	00 00 00	 cmp	 QWORD PTR fRem$[rbp], 0
  004e8	75 90		 jne	 SHORT $LN9@numConvert

; 195  : 
; 196  : 			ptr -= 1;

  004ea	48 8b 45 08	 mov	 rax, QWORD PTR ptr$[rbp]
  004ee	48 ff c8	 dec	 rax
  004f1	48 89 45 08	 mov	 QWORD PTR ptr$[rbp], rax

; 197  : 			*ptr = '.';

  004f5	48 8b 45 08	 mov	 rax, QWORD PTR ptr$[rbp]
  004f9	c6 00 2e	 mov	 BYTE PTR [rax], 46	; 0000002eH
$LN28@numConvert:
$LN27@numConvert:

; 198  : 		}
; 199  : 	}
; 200  : 
; 201  : 	if (isFloat || isInt) { // whole integer section

  004fc	83 bd 84 00 00
	00 00		 cmp	 DWORD PTR isFloat$[rbp], 0
  00503	75 0a		 jne	 SHORT $LN31@numConvert
  00505	83 7d 64 00	 cmp	 DWORD PTR isInt$[rbp], 0
  00509	0f 84 8a 00 00
	00		 je	 $LN29@numConvert
$LN31@numConvert:
$LN12@numConvert:

; 202  : 		do
; 203  : 		{
; 204  : 			ptr -= 1;

  0050f	48 8b 45 08	 mov	 rax, QWORD PTR ptr$[rbp]
  00513	48 ff c8	 dec	 rax
  00516	48 89 45 08	 mov	 QWORD PTR ptr$[rbp], rax

; 205  : 			*ptr = Representation[iVal % base];

  0051a	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR base$[rbp]
  00520	48 89 85 18 02
	00 00		 mov	 QWORD PTR tv163[rbp], rax
  00527	33 d2		 xor	 edx, edx
  00529	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR iVal$[rbp]
  00530	48 8b 8d 18 02
	00 00		 mov	 rcx, QWORD PTR tv163[rbp]
  00537	48 f7 f1	 div	 rcx
  0053a	48 8b c2	 mov	 rax, rdx
  0053d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Representation@?1??numConvert@@9@9
  00544	48 8b 55 08	 mov	 rdx, QWORD PTR ptr$[rbp]
  00548	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0054c	88 02		 mov	 BYTE PTR [rdx], al

; 206  : 			iVal /= base;

  0054e	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR base$[rbp]
  00554	48 89 85 18 02
	00 00		 mov	 QWORD PTR tv167[rbp], rax
  0055b	33 d2		 xor	 edx, edx
  0055d	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR iVal$[rbp]
  00564	48 8b 8d 18 02
	00 00		 mov	 rcx, QWORD PTR tv167[rbp]
  0056b	48 f7 f1	 div	 rcx
  0056e	48 89 85 08 01
	00 00		 mov	 QWORD PTR iVal$[rbp], rax

; 207  : 
; 208  : 		} while (iVal != 0);

  00575	48 83 bd 08 01
	00 00 00	 cmp	 QWORD PTR iVal$[rbp], 0
  0057d	75 90		 jne	 SHORT $LN12@numConvert

; 209  : 
; 210  : 		if (!isPositive)

  0057f	83 7d 44 00	 cmp	 DWORD PTR isPositive$[rbp], 0
  00583	75 12		 jne	 SHORT $LN32@numConvert

; 211  : 		{
; 212  : 			ptr -= 1;

  00585	48 8b 45 08	 mov	 rax, QWORD PTR ptr$[rbp]
  00589	48 ff c8	 dec	 rax
  0058c	48 89 45 08	 mov	 QWORD PTR ptr$[rbp], rax

; 213  : 			*ptr = '-';

  00590	48 8b 45 08	 mov	 rax, QWORD PTR ptr$[rbp]
  00594	c6 00 2d	 mov	 BYTE PTR [rax], 45	; 0000002dH
$LN32@numConvert:

; 214  : 		}
; 215  : 	}

  00597	eb 42		 jmp	 SHORT $LN30@numConvert
$LN29@numConvert:
$LN15@numConvert:

; 216  : 
; 217  : 	else { // binary section
; 218  : 		do
; 219  : 		{
; 220  : 			ptr -= 1;

  00599	48 8b 45 08	 mov	 rax, QWORD PTR ptr$[rbp]
  0059d	48 ff c8	 dec	 rax
  005a0	48 89 45 08	 mov	 QWORD PTR ptr$[rbp], rax

; 221  : 			*ptr = Representation[iVal & 1];

  005a4	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR iVal$[rbp]
  005ab	48 83 e0 01	 and	 rax, 1
  005af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Representation@?1??numConvert@@9@9
  005b6	48 8b 55 08	 mov	 rdx, QWORD PTR ptr$[rbp]
  005ba	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  005be	88 02		 mov	 BYTE PTR [rdx], al

; 222  : 			iVal = iVal >> 1;

  005c0	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR iVal$[rbp]
  005c7	48 d1 e8	 shr	 rax, 1
  005ca	48 89 85 08 01
	00 00		 mov	 QWORD PTR iVal$[rbp], rax

; 223  : 
; 224  : 		} while (iVal != 0);

  005d1	48 83 bd 08 01
	00 00 00	 cmp	 QWORD PTR iVal$[rbp], 0
  005d9	75 be		 jne	 SHORT $LN15@numConvert
$LN30@numConvert:

; 225  : 	}
; 226  : 
; 227  : 	ptr -= 1;

  005db	48 8b 45 08	 mov	 rax, QWORD PTR ptr$[rbp]
  005df	48 ff c8	 dec	 rax
  005e2	48 89 45 08	 mov	 QWORD PTR ptr$[rbp], rax

; 228  : 	*ptr = ParamSymbol[preem._type];

  005e6	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR preem$[rbp]
  005ed	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  005f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?ParamSymbol@?1??numConvert@@9@9
  005f7	48 8b 55 08	 mov	 rdx, QWORD PTR ptr$[rbp]
  005fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  005ff	88 02		 mov	 BYTE PTR [rdx], al

; 229  : 	ptr -= 1;

  00601	48 8b 45 08	 mov	 rax, QWORD PTR ptr$[rbp]
  00605	48 ff c8	 dec	 rax
  00608	48 89 45 08	 mov	 QWORD PTR ptr$[rbp], rax

; 230  : 	*ptr = Representation[0];

  0060c	b8 01 00 00 00	 mov	 eax, 1
  00611	48 6b c0 00	 imul	 rax, rax, 0
  00615	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Representation@?1??numConvert@@9@9
  0061c	48 8b 55 08	 mov	 rdx, QWORD PTR ptr$[rbp]
  00620	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00624	88 02		 mov	 BYTE PTR [rdx], al

; 231  : 
; 232  : 	return(ptr);

  00626	48 8b 45 08	 mov	 rax, QWORD PTR ptr$[rbp]

; 233  : }

  0062a	48 8d a5 28 02
	00 00		 lea	 rsp, QWORD PTR [rbp+552]
  00631	5f		 pop	 rdi
  00632	5d		 pop	 rbp
  00633	c3		 ret	 0
$LN52@numConvert:
  00634	00 00 00 00	 DD	 $LN18@numConvert
  00638	00 00 00 00	 DD	 $LN17@numConvert
  0063c	00 00 00 00	 DD	 $LN19@numConvert
  00640	00 00 00 00	 DD	 $LN20@numConvert
  00644	00 00 00 00	 DD	 $LN21@numConvert
  00648	00 00 00 00	 DD	 $LN16@numConvert
  0064c	00 00 00 00	 DD	 $LN22@numConvert
  00650	00 00 00 00	 DD	 $LN23@numConvert
  00654	00 00 00 00	 DD	 $LN24@numConvert
  00658	00 00 00 00	 DD	 $LN25@numConvert
  0065c	00 00 00 00	 DD	 $LN26@numConvert
numConvert ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tPreent.c
;	COMDAT strToInt
_TEXT	SEGMENT
numStart$ = 4
isNegative$ = 36
output$ = 68
start$ = 100
end$ = 132
tv80 = 340
input$ = 384
strToInt PROC						; COMDAT

; 69   : {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__386B16A1_tPreent@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 70   : 	int numStart = 0;

  0001f	c7 45 04 00 00
	00 00		 mov	 DWORD PTR numStart$[rbp], 0

; 71   : 	int isNegative = 0;

  00026	c7 45 24 00 00
	00 00		 mov	 DWORD PTR isNegative$[rbp], 0

; 72   : 	int output = 0;

  0002d	c7 45 44 00 00
	00 00		 mov	 DWORD PTR output$[rbp], 0

; 73   : 
; 74   : 	char start = '0';

  00034	c6 45 64 30	 mov	 BYTE PTR start$[rbp], 48 ; 00000030H

; 75   : 	char end = '9';

  00038	c6 85 84 00 00
	00 39		 mov	 BYTE PTR end$[rbp], 57	; 00000039H
$LN2@strToInt:

; 76   : 
; 77   : 	while (*input != '\0')

  0003f	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR input$[rbp]
  00046	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00049	85 c0		 test	 eax, eax
  0004b	74 7c		 je	 SHORT $LN3@strToInt

; 78   : 	{
; 79   : 		if (!numStart && *input == '-')

  0004d	83 7d 04 00	 cmp	 DWORD PTR numStart$[rbp], 0
  00051	75 16		 jne	 SHORT $LN4@strToInt
  00053	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR input$[rbp]
  0005a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0005d	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00060	75 07		 jne	 SHORT $LN4@strToInt

; 80   : 			isNegative = 1;

  00062	c7 45 24 01 00
	00 00		 mov	 DWORD PTR isNegative$[rbp], 1
$LN4@strToInt:

; 81   : 
; 82   : 
; 83   : 		if (*input >= '0' && *input <= '9')

  00069	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR input$[rbp]
  00070	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00073	83 f8 30	 cmp	 eax, 48			; 00000030H
  00076	7c 33		 jl	 SHORT $LN5@strToInt
  00078	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR input$[rbp]
  0007f	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00082	83 f8 39	 cmp	 eax, 57			; 00000039H
  00085	7f 24		 jg	 SHORT $LN5@strToInt

; 84   : 		{
; 85   : 			numStart = 1;

  00087	c7 45 04 01 00
	00 00		 mov	 DWORD PTR numStart$[rbp], 1

; 86   : 
; 87   : 			output *= 10;

  0008e	6b 45 44 0a	 imul	 eax, DWORD PTR output$[rbp], 10
  00092	89 45 44	 mov	 DWORD PTR output$[rbp], eax

; 88   : 			output += *input - 48;

  00095	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR input$[rbp]
  0009c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0009f	8b 4d 44	 mov	 ecx, DWORD PTR output$[rbp]
  000a2	8d 44 01 d0	 lea	 eax, DWORD PTR [rcx+rax-48]
  000a6	89 45 44	 mov	 DWORD PTR output$[rbp], eax

; 89   : 		}

  000a9	eb 08		 jmp	 SHORT $LN6@strToInt
$LN5@strToInt:

; 90   : 		else if (numStart)

  000ab	83 7d 04 00	 cmp	 DWORD PTR numStart$[rbp], 0
  000af	74 02		 je	 SHORT $LN7@strToInt

; 91   : 			break;

  000b1	eb 16		 jmp	 SHORT $LN3@strToInt
$LN7@strToInt:
$LN6@strToInt:

; 92   : 
; 93   : 		input++;

  000b3	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR input$[rbp]
  000ba	48 ff c0	 inc	 rax
  000bd	48 89 85 80 01
	00 00		 mov	 QWORD PTR input$[rbp], rax

; 94   : 	}

  000c4	e9 76 ff ff ff	 jmp	 $LN2@strToInt
$LN3@strToInt:

; 95   : 
; 96   : 	output *= isNegative ? -1 : 1;

  000c9	83 7d 24 00	 cmp	 DWORD PTR isNegative$[rbp], 0
  000cd	74 0c		 je	 SHORT $LN9@strToInt
  000cf	c7 85 54 01 00
	00 ff ff ff ff	 mov	 DWORD PTR tv80[rbp], -1
  000d9	eb 0a		 jmp	 SHORT $LN10@strToInt
$LN9@strToInt:
  000db	c7 85 54 01 00
	00 01 00 00 00	 mov	 DWORD PTR tv80[rbp], 1
$LN10@strToInt:
  000e5	8b 45 44	 mov	 eax, DWORD PTR output$[rbp]
  000e8	0f af 85 54 01
	00 00		 imul	 eax, DWORD PTR tv80[rbp]
  000ef	89 45 44	 mov	 DWORD PTR output$[rbp], eax

; 97   : 
; 98   : 	return output;

  000f2	8b 45 44	 mov	 eax, DWORD PTR output$[rbp]

; 99   : }

  000f5	48 8d a5 68 01
	00 00		 lea	 rsp, QWORD PTR [rbp+360]
  000fc	5f		 pop	 rdi
  000fd	5d		 pop	 rbp
  000fe	c3		 ret	 0
strToInt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tPreent.c
;	COMDAT integerConvert
_TEXT	SEGMENT
ptr$ = 8
num$ = 256
base$ = 264
integerConvert PROC					; COMDAT

; 44   : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	55		 push	 rbp
  00009	57		 push	 rdi
  0000a	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00011	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__386B16A1_tPreent@c
  0001d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 45   : 	static char Representation[] = "0123456789ABCDEF";
; 46   : 	static char iBuffer[MAX_NUM_BUFFER];
; 47   : 
; 48   : 
; 49   : 	char* ptr = &iBuffer[MAX_NUM_BUFFER - 1];

  00022	b8 01 00 00 00	 mov	 eax, 1
  00027	48 6b c0 31	 imul	 rax, rax, 49		; 00000031H
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?iBuffer@?1??integerConvert@@9@9
  00032	48 03 c8	 add	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	48 89 45 08	 mov	 QWORD PTR ptr$[rbp], rax

; 50   : 	*ptr = '\0';

  0003c	48 8b 45 08	 mov	 rax, QWORD PTR ptr$[rbp]
  00040	c6 00 00	 mov	 BYTE PTR [rax], 0
$LN4@integerCon:

; 51   : 
; 52   : 	do
; 53   : 	{
; 54   : 		ptr -= 1;

  00043	48 8b 45 08	 mov	 rax, QWORD PTR ptr$[rbp]
  00047	48 ff c8	 dec	 rax
  0004a	48 89 45 08	 mov	 QWORD PTR ptr$[rbp], rax

; 55   : 		*ptr = Representation[num % base];

  0004e	33 d2		 xor	 edx, edx
  00050	8b 85 00 01 00
	00		 mov	 eax, DWORD PTR num$[rbp]
  00056	f7 b5 08 01 00
	00		 div	 DWORD PTR base$[rbp]
  0005c	8b c2		 mov	 eax, edx
  0005e	8b c0		 mov	 eax, eax
  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Representation@?1??integerConvert@@9@9
  00067	48 8b 55 08	 mov	 rdx, QWORD PTR ptr$[rbp]
  0006b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0006f	88 02		 mov	 BYTE PTR [rdx], al

; 56   : 		num /= base;

  00071	33 d2		 xor	 edx, edx
  00073	8b 85 00 01 00
	00		 mov	 eax, DWORD PTR num$[rbp]
  00079	f7 b5 08 01 00
	00		 div	 DWORD PTR base$[rbp]
  0007f	89 85 00 01 00
	00		 mov	 DWORD PTR num$[rbp], eax

; 57   : 	} while (num != 0);

  00085	83 bd 00 01 00
	00 00		 cmp	 DWORD PTR num$[rbp], 0
  0008c	75 b5		 jne	 SHORT $LN4@integerCon

; 58   : 
; 59   : 	return(ptr);

  0008e	48 8b 45 08	 mov	 rax, QWORD PTR ptr$[rbp]

; 60   : }

  00092	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00099	5f		 pop	 rdi
  0009a	5d		 pop	 rbp
  0009b	c3		 ret	 0
integerConvert ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tPreent.c
;	COMDAT pootStr
_TEXT	SEGMENT
length$ = 4
str$ = 256
output$ = 264
written$ = 272
pootStr	PROC						; COMDAT

; 27   : {

$LN4:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00018	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__386B16A1_tPreent@c
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 28   : 	//HANDLE output = GetStdHandle(STD_OUTPUT_HANDLE);
; 29   : 	//DWORD written = 0;
; 30   : 
; 31   : 	//while (*str != '\0')
; 32   : 	//{
; 33   : 	unsigned int length = strLenSafe(str);

  00029	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR str$[rbp]
  00030	e8 00 00 00 00	 call	 strLenSafe
  00035	89 45 04	 mov	 DWORD PTR length$[rbp], eax

; 34   : 
; 35   : 	if (!length)

  00038	83 7d 04 00	 cmp	 DWORD PTR length$[rbp], 0
  0003c	75 02		 jne	 SHORT $LN2@pootStr

; 36   : 		return;

  0003e	eb 28		 jmp	 SHORT $LN1@pootStr
$LN2@pootStr:

; 37   : 
; 38   : 	WriteConsoleA(output, str, length, &written, NULL);

  00040	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00049	4c 8d 8d 10 01
	00 00		 lea	 r9, QWORD PTR written$[rbp]
  00050	44 8b 45 04	 mov	 r8d, DWORD PTR length$[rbp]
  00054	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR str$[rbp]
  0005b	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR output$[rbp]
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WriteConsoleA
$LN1@pootStr:

; 39   : 	//str++;
; 40   : //}
; 41   : }

  00068	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0006f	5f		 pop	 rdi
  00070	5d		 pop	 rbp
  00071	c3		 ret	 0
pootStr	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tPreent.c
;	COMDAT pootChar
_TEXT	SEGMENT
put$ = 224
output$ = 232
written$ = 240
pootChar PROC						; COMDAT

; 19   : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00017	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__386B16A1_tPreent@c
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 20   : 	//HANDLE output = GetStdHandle(STD_OUTPUT_HANDLE);
; 21   : 	//DWORD written = 0;
; 22   : 
; 23   : 	WriteConsoleA(output, &put, 1, &written, NULL);

  00028	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00031	4c 8d 8d f0 00
	00 00		 lea	 r9, QWORD PTR written$[rbp]
  00038	41 b8 01 00 00
	00		 mov	 r8d, 1
  0003e	48 8d 95 e0 00
	00 00		 lea	 rdx, QWORD PTR put$[rbp]
  00045	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR output$[rbp]
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WriteConsoleA

; 24   : }

  00052	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00059	5f		 pop	 rdi
  0005a	5d		 pop	 rbp
  0005b	c3		 ret	 0
pootChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tPreent.c
;	COMDAT strLenSafe
_TEXT	SEGMENT
count$ = 4
str$ = 256
strLenSafe PROC						; COMDAT

; 4    : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__386B16A1_tPreent@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5    : 	if (!str)

  0001f	48 83 bd 00 01
	00 00 00	 cmp	 QWORD PTR str$[rbp], 0
  00027	75 04		 jne	 SHORT $LN4@strLenSafe

; 6    : 		return 0;

  00029	33 c0		 xor	 eax, eax
  0002b	eb 34		 jmp	 SHORT $LN1@strLenSafe
$LN4@strLenSafe:

; 7    : 	unsigned int count = 1;

  0002d	c7 45 04 01 00
	00 00		 mov	 DWORD PTR count$[rbp], 1
$LN2@strLenSafe:

; 8    : 	while (str[count - 1] != '\0')

  00034	8b 45 04	 mov	 eax, DWORD PTR count$[rbp]
  00037	ff c8		 dec	 eax
  00039	8b c0		 mov	 eax, eax
  0003b	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR str$[rbp]
  00042	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00046	85 c0		 test	 eax, eax
  00048	74 14		 je	 SHORT $LN3@strLenSafe

; 9    : 	{
; 10   : 		if (count > MAX_CONSOLE_BUFFER)

  0004a	83 7d 04 40	 cmp	 DWORD PTR count$[rbp], 64 ; 00000040H
  0004e	76 04		 jbe	 SHORT $LN5@strLenSafe

; 11   : 			return 0;

  00050	33 c0		 xor	 eax, eax
  00052	eb 0d		 jmp	 SHORT $LN1@strLenSafe
$LN5@strLenSafe:

; 12   : 		count++;

  00054	8b 45 04	 mov	 eax, DWORD PTR count$[rbp]
  00057	ff c0		 inc	 eax
  00059	89 45 04	 mov	 DWORD PTR count$[rbp], eax

; 13   : 	}

  0005c	eb d6		 jmp	 SHORT $LN2@strLenSafe
$LN3@strLenSafe:

; 14   : 
; 15   : 	return count;

  0005e	8b 45 04	 mov	 eax, DWORD PTR count$[rbp]
$LN1@strLenSafe:

; 16   : }

  00061	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00068	5f		 pop	 rdi
  00069	5d		 pop	 rbp
  0006a	c3		 ret	 0
strLenSafe ENDP
_TEXT	ENDS
END
