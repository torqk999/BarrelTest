; Listing generated by Microsoft (R) Optimizing Compiler Version 19.39.33523.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__9C67CA7D_tEnums@h DB 01H
__EAEE5CFA_tDefines@h DB 01H
__0ED14FEE_winpackagefamily@h DB 01H
__F92EF742_winapifamily@h DB 01H
__22E515EB_sdkddkver@h DB 01H
__FE09AF47_concurrencysal@h DB 01H
__C073CA79_sal@h DB 01H
__D6AFE870_vadefs@h DB 01H
__D63E96CF_vcruntime@h DB 01H
__514B86D7_excpt@h DB 01H
__9A7D38D9_stdarg@h DB 01H
__29F49F40_specstrings_undef@h DB 01H
__D0F42932_specstrings_strict@h DB 01H
__F00405FD_sdv_driverspecs@h DB 01H
__173E09CA_driverspecs@h DB 01H
__9A452361_specstrings@h DB 01H
__1B0272D9_corecrt@h DB 01H
__74484FB3_corecrt_wctype@h DB 01H
__1EC467ED_ctype@h DB 01H
__98517906_kernelspecs@h DB 01H
__D3497022_basetsd@h DB 01H
__61CC25A1_errno@h DB 01H
__3EADF068_vcruntime_string@h DB 01H
__E4C945B4_corecrt_memcpy_s@h DB 01H
__8EAFF484_corecrt_memory@h DB 01H
__6490AEC5_corecrt_wstring@h DB 01H
__E8295E1E_string@h DB 01H
__7FCB5136_guiddef@h DB 01H
__FF8A9E11_pshpack4@h DB 01H
__D5438902_poppack@h DB 01H
__FB07E2A3_pshpack2@h DB 01H
__F6906775_pshpack8@h DB 01H
__F9415CFA_pshpack1@h DB 01H
__E58C6F1C_apiset@h DB 01H
__A5C52262_ktmtypes@h DB 01H
__FBBA8F9D_winnt@h DB 01H
__A32D3D2C_minwindef@h DB 01H
__7D798299_windef@h DB 01H
__9AE108E9_apisetcconv@h DB 01H
__9CE53D2C_minwinbase@h DB 01H
__5D0AA210_apiquery2@h DB 01H
__4DD4E726_processenv@h DB 01H
__3575CC96_fileapi@h DB 01H
__8EA220E6_fileapifromapp@h DB 01H
__BF9B31FE_debugapi@h DB 01H
__C3AFE134_utilapiset@h DB 01H
__76F69E51_handleapi@h DB 01H
__7E63D784_errhandlingapi@h DB 01H
__FFA7003C_fibersapi@h DB 01H
__8971CECF_namedpipeapi@h DB 01H
__46C9D8A6_profileapi@h DB 01H
__98D4F0A3_heapapi@h DB 01H
__50EF2A88_ioapiset@h DB 01H
__92EA1464_synchapi@h DB 01H
__A53D8AED_interlockedapi@h DB 01H
__B506CAAF_processthreadsapi@h DB 01H
__FF735694_sysinfoapi@h DB 01H
__29589789_memoryapi@h DB 01H
__E9C7A663_enclaveapi@h DB 01H
__D035F9F7_threadpoollegacyapiset@h DB 01H
__C899130C_threadpoolapiset@h DB 01H
__E0441EE7_jobapi@h DB 01H
__CEF86838_jobapi2@h DB 01H
__35AC6B9A_wow64apiset@h DB 01H
__C8AE41A5_libloaderapi@h DB 01H
__CC9E232D_securitybaseapi@h DB 01H
__C9D0C9B8_namespaceapi@h DB 01H
__30FF9CAD_systemtopologyapi@h DB 01H
__4D358795_processtopologyapi@h DB 01H
__40446D10_securityappcontainer@h DB 01H
__3A952EDF_realtimeapiset@h DB 01H
__F4865F4B_winerror@h DB 01H
__53C1BD93_timezoneapi@h DB 01H
__1FFBEDBF_winbase@h DB 01H
__43D3FA34_wingdi@h DB 01H
__D24A7391_tvout@h DB 01H
__7713A6C8_winuser@h DB 01H
__0B345F71_datetimeapi@h DB 01H
__9AC6960C_winnls@h DB 01H
__973A40A8_stringapiset@h DB 01H
__CC46FEE2_wincontypes@h DB 01H
__97D70BE1_consoleapi@h DB 01H
__27EC5E18_consoleapi2@h DB 01H
__262E342F_consoleapi3@h DB 01H
__641DCD70_wincon@h DB 01H
__5A96C7A7_verrsrc@h DB 01H
__B69C6FF2_winver@h DB 01H
__7AEB8C37_reason@h DB 01H
__59F1A8A9_winreg@h DB 01H
__EE0E2B7F_wnnc@h DB 01H
__DCDB7054_winnetwk@h DB 01H
__EDC72EEB_cderr@h DB 01H
__95F9199D_dde@h DB 01H
__66427627_ddeml@h DB 01H
__957C29A0_dlgs@h DB 01H
__12EA15AF_lzexpand@h DB 01H
__62131F15_mmsyscom@h DB 01H
__47E68D49_mciapi@h DB 01H
__5D7DD356_mmiscapi@h DB 01H
__7223D2EF_mmiscapi2@h DB 01H
__A330DBB3_playsoundapi@h DB 01H
__601B366F_mmeapi@h DB 01H
__1134ADD5_timeapi@h DB 01H
__93F2265A_joystickapi@h DB 01H
__DF6EB4E3_mmsystem@h DB 01H
__BD641FCB_nb30@h DB 01H
__DF8704F0_rpcdcep@h DB 01H
__5C6CA7BB_rpcdce@h DB 01H
__853533C4_rpcnsi@h DB 01H
__2D2406C3_rpcnterr@h DB 01H
__64521D71_rpcasync@h DB 01H
__AADCBA08_rpc@h DB 01H
__19E26CFF_shellapi@h DB 01H
__1E9F31D3_winperf@h DB 01H
__832A4112_inaddr@h DB 01H
__32C6F875_winsock@h DB 01H
__7953A3F8_bcrypt@h DB 01H
__E4169492_ncrypt@h DB 01H
__AF3DDDC3_dpapi@h DB 01H
__D1E23BF2_wincrypt@h DB 01H
__82AB4779_winefs@h DB 01H
__1FE431C9_rpcnsip@h DB 01H
__2B741F2D_rpcsal@h DB 01H
__92623256_rpcndr@h DB 01H
__9C18532E_wtypesbase@h DB 01H
__EA2E1D6D_wtypes@h DB 01H
__7DDD9F45_winioctl@h DB 01H
__E550A843_winsmcrd@h DB 01H
__9809C1BA_winscard@h DB 01H
__EA174FA4_prsht@h DB 01H
__0E1BD114_winspool@h DB 01H
__45DED006_corecrt_malloc@h DB 01H
__13F5961F_stddef@h DB 01H
__FD6DBD68_corecrt_search@h DB 01H
__E2E33A61_corecrt_wstdlib@h DB 01H
__10D4A829_limits@h DB 01H
__6E5ACABA_stdlib@h DB 01H
__30B1AFDA_unknwnbase@h DB 01H
__328C1996_objidlbase@h DB 01H
__C4E06B6A_cguid@h DB 01H
__434718C5_combaseapi@h DB 01H
__DE6FDEF1_unknwn@h DB 01H
__CCE0BACC_objidl@h DB 01H
__8C7011E5_oaidl@h DB 01H
__2E0B7863_propidlbase@h DB 01H
__BF4CF2EC_coml2api@h DB 01H
__6D897344_oleidl@h DB 01H
__1129FC2C_servprov@h DB 01H
__757952E4_msxml@h DB 01H
__B1191D53_urlmon@h DB 01H
__404D1A47_propidl@h DB 01H
__A1C63593_objbase@h DB 01H
__C1B0A9CB_oleauto@h DB 01H
__24EAF61F_ole2@h DB 01H
__2B1843DA_commdlg@h DB 01H
__81DDEDE3_stralign@h DB 01H
__2134D1B4_winsvc@h DB 01H
__11C07376_mcx@h DB 01H
__577CE3E7_ime_cmodes@h DB 01H
__1E72C31E_imm@h DB 01H
__63AA7AF5_Windows@h DB 01H
__4EC676C0_tModules@h DB 01H
__AFB9CF29_tPreent@h DB 01H
__366DFDC4_tHelpers@h DB 01H
__A1BF244C_tHelpers@c DB 01H
msvcjmc	ENDS
PUBLIC	CreateRequest
PUBLIC	Clamp
PUBLIC	ClampInt
PUBLIC	pow
PUBLIC	defaultCharCompare
PUBLIC	defaultStringCompare
PUBLIC	UnsignedIntegralCompare
PUBLIC	SignedIntegralCompare
PUBLIC	FloatingCompare
PUBLIC	findSubStringCustom
PUBLIC	findSubString
PUBLIC	paramCount
PUBLIC	paramCount0
PUBLIC	stringTranscribe
PUBLIC	rawTranscribe
PUBLIC	barrelTranscribe
PUBLIC	TranscribeElement
PUBLIC	TranscribeSpan
PUBLIC	defaultSubStringCompare
PUBLIC	__JustMyCode_Default
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__ImageBase:BYTE
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$CreateRequest DD imagerel $LN8
	DD	imagerel $LN8+311
	DD	imagerel $unwind$CreateRequest
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Clamp DD	imagerel $LN7
	DD	imagerel $LN7+172
	DD	imagerel $unwind$Clamp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ClampInt DD imagerel $LN7
	DD	imagerel $LN7+141
	DD	imagerel $unwind$ClampInt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pow DD	imagerel $LN6
	DD	imagerel $LN6+97
	DD	imagerel $unwind$pow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$defaultCharCompare DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$defaultCharCompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$defaultStringCompare DD imagerel $LN8
	DD	imagerel $LN8+167
	DD	imagerel $unwind$defaultStringCompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$UnsignedIntegralCompare DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$UnsignedIntegralCompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SignedIntegralCompare DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$SignedIntegralCompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$FloatingCompare DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$FloatingCompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$findSubStringCustom DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$findSubStringCustom
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$findSubString DD imagerel $LN6
	DD	imagerel $LN6+115
	DD	imagerel $unwind$findSubString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$paramCount DD imagerel $LN6
	DD	imagerel $LN6+107
	DD	imagerel $unwind$paramCount
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$paramCount0 DD imagerel $LN22
	DD	imagerel $LN22+394
	DD	imagerel $unwind$paramCount0
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringTranscribe DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$stringTranscribe
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rawTranscribe DD imagerel $LN8
	DD	imagerel $LN8+164
	DD	imagerel $unwind$rawTranscribe
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$barrelTranscribe DD imagerel $LN6
	DD	imagerel $LN6+126
	DD	imagerel $unwind$barrelTranscribe
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TranscribeElement DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$TranscribeElement
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TranscribeSpan DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$TranscribeSpan
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$defaultSubStringCompare DD imagerel $LN6
	DD	imagerel $LN6+125
	DD	imagerel $unwind$defaultSubStringCompare
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$defaultSubStringCompare DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TranscribeSpan DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TranscribeElement DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$barrelTranscribe DD 025061e01H
	DD	0119231eH
	DD	070120020H
	DD	050106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rawTranscribe DD 025051d01H
	DD	0118231dH
	DD	070110021H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringTranscribe DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$paramCount0 DD 025051301H
	DD	010e2313H
	DD	070070029H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$paramCount DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$findSubString DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$findSubStringCustom DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$FloatingCompare DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SignedIntegralCompare DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UnsignedIntegralCompare DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$defaultStringCompare DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$defaultCharCompare DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pow DD	025051601H
	DD	01112316H
	DD	0700a0025H
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ClampInt DD 025051b01H
	DD	0116231bH
	DD	0700f001fH
	DD	0500eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Clamp DD 025052001H
	DD	011b2320H
	DD	07014001fH
	DD	05013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CreateRequest DD 025053a01H
	DD	011c2321H
	DD	070150033H
	DD	05014H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
CreateRequest$rtcName$0 DB 06fH
	DB	075H
	DB	074H
	DB	070H
	DB	075H
	DB	074H
	DB	00H
	ORG $+9
CreateRequest$rtcVarDesc DD 028H
	DD	010H
	DQ	FLAT:CreateRequest$rtcName$0
	ORG $+48
CreateRequest$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:CreateRequest$rtcVarDesc
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	c2 00 00	 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tHelpers.c
;	COMDAT defaultSubStringCompare
_TEXT	SEGMENT
seek$ = 4
sub$ = 256
str$ = 264
defaultSubStringCompare PROC				; COMDAT

; 46   : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A1BF244C_tHelpers@c
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 47   : 	int seek = 0;

  00024	c7 45 04 00 00
	00 00		 mov	 DWORD PTR seek$[rbp], 0
$LN2@defaultSub:

; 48   : 	while (sub[seek] != '\0') {

  0002b	48 63 45 04	 movsxd	 rax, DWORD PTR seek$[rbp]
  0002f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR sub$[rbp]
  00036	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0003a	85 c0		 test	 eax, eax
  0003c	74 30		 je	 SHORT $LN3@defaultSub

; 49   : 		if (sub[seek] != str[seek])

  0003e	48 63 45 04	 movsxd	 rax, DWORD PTR seek$[rbp]
  00042	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR sub$[rbp]
  00049	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0004d	48 63 4d 04	 movsxd	 rcx, DWORD PTR seek$[rbp]
  00051	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR str$[rbp]
  00058	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  0005c	3b c1		 cmp	 eax, ecx
  0005e	74 04		 je	 SHORT $LN4@defaultSub

; 50   : 			return false;

  00060	33 c0		 xor	 eax, eax
  00062	eb 0f		 jmp	 SHORT $LN1@defaultSub
$LN4@defaultSub:

; 51   : 		seek++;

  00064	8b 45 04	 mov	 eax, DWORD PTR seek$[rbp]
  00067	ff c0		 inc	 eax
  00069	89 45 04	 mov	 DWORD PTR seek$[rbp], eax

; 52   : 	}

  0006c	eb bd		 jmp	 SHORT $LN2@defaultSub
$LN3@defaultSub:

; 53   : 	return true;

  0006e	b8 01 00 00 00	 mov	 eax, 1
$LN1@defaultSub:

; 54   : }

  00073	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0007a	5f		 pop	 rdi
  0007b	5d		 pop	 rbp
  0007c	c3		 ret	 0
defaultSubStringCompare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tHelpers.c
;	COMDAT TranscribeSpan
_TEXT	SEGMENT
request$ = 224
TranscribeSpan PROC					; COMDAT

; 194  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A1BF244C_tHelpers@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 195  : 	//int dir = request._size < 0 ? -1 : 1;
; 196  : 	//unsigned long long count = request._size * dir;
; 197  : 	//
; 198  : 	//for (unsigned long long i = 0; i < count; i++)
; 199  : 	//{
; 200  : 	//	TranscribeElement(request);
; 201  : 	//	request._srcIx += dir;
; 202  : 	//	request._trgIx += dir;
; 203  : 	//}
; 204  : 
; 205  : }

  0001f	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00026	5f		 pop	 rdi
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
TranscribeSpan ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tHelpers.c
;	COMDAT TranscribeElement
_TEXT	SEGMENT
request$ = 224
TranscribeElement PROC					; COMDAT

; 184  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A1BF244C_tHelpers@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 185  : 	//rawTranscribe(
; 186  : 	//	request._src ?
; 187  : 	//		((size_t)request._src + (request._srcIx * request._size)) :
; 188  : 	//		NULL,
; 189  : 	//	((size_t)request._trg + (request._trgIx * request._size)),
; 190  : 	//	request._size);
; 191  : }

  0001f	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00026	5f		 pop	 rdi
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
TranscribeElement ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tHelpers.c
;	COMDAT barrelTranscribe
_TEXT	SEGMENT
i$1 = 4
trg$ = 256
src$ = 264
count$ = 272
barrelTranscribe PROC					; COMDAT

; 178  : {

$LN6:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	48 81 ec 00 01
	00 00		 sub	 rsp, 256		; 00000100H
  00019	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A1BF244C_tHelpers@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 179  : 	for (unsigned int i = 0; i < count; i++)

  0002a	c7 45 04 00 00
	00 00		 mov	 DWORD PTR i$1[rbp], 0
  00031	eb 08		 jmp	 SHORT $LN4@barrelTran
$LN2@barrelTran:
  00033	8b 45 04	 mov	 eax, DWORD PTR i$1[rbp]
  00036	ff c0		 inc	 eax
  00038	89 45 04	 mov	 DWORD PTR i$1[rbp], eax
$LN4@barrelTran:
  0003b	8b 85 10 01 00
	00		 mov	 eax, DWORD PTR count$[rbp]
  00041	39 45 04	 cmp	 DWORD PTR i$1[rbp], eax
  00044	73 2d		 jae	 SHORT $LN3@barrelTran

; 180  : 		((Barrel*)trg)[i] = ((Barrel*)src)[i];

  00046	8b 45 04	 mov	 eax, DWORD PTR i$1[rbp]
  00049	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0004d	8b 4d 04	 mov	 ecx, DWORD PTR i$1[rbp]
  00050	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  00054	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR trg$[rbp]
  0005b	4c 8b 85 08 01
	00 00		 mov	 r8, QWORD PTR src$[rbp]
  00062	48 8d 3c 0a	 lea	 rdi, QWORD PTR [rdx+rcx]
  00066	49 8d 34 00	 lea	 rsi, QWORD PTR [r8+rax]
  0006a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0006f	f3 a4		 rep movsb
  00071	eb c0		 jmp	 SHORT $LN2@barrelTran
$LN3@barrelTran:

; 181  : }

  00073	48 8d a5 e0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+224]
  0007a	5f		 pop	 rdi
  0007b	5e		 pop	 rsi
  0007c	5d		 pop	 rbp
  0007d	c3		 ret	 0
barrelTranscribe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tHelpers.c
;	COMDAT rawTranscribe
_TEXT	SEGMENT
i$1 = 8
tv72 = 216
trg$ = 256
src$ = 264
size$ = 272
rawTranscribe PROC					; COMDAT

; 172  : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A1BF244C_tHelpers@c
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 173  : 	for (size_t i = 0; i < size; i++)

  00029	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  00031	eb 0b		 jmp	 SHORT $LN4@rawTranscr
$LN2@rawTranscr:
  00033	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00037	48 ff c0	 inc	 rax
  0003a	48 89 45 08	 mov	 QWORD PTR i$1[rbp], rax
$LN4@rawTranscr:
  0003e	48 8b 85 10 01
	00 00		 mov	 rax, QWORD PTR size$[rbp]
  00045	48 39 45 08	 cmp	 QWORD PTR i$1[rbp], rax
  00049	73 4f		 jae	 SHORT $LN3@rawTranscr

; 174  : 		((char*)trg)[i] = src ? ((char*)src)[i] : NULL;

  0004b	48 83 bd 08 01
	00 00 00	 cmp	 QWORD PTR src$[rbp], 0
  00053	74 1e		 je	 SHORT $LN6@rawTranscr
  00055	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00059	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR src$[rbp]
  00060	48 03 c8	 add	 rcx, rax
  00063	48 8b c1	 mov	 rax, rcx
  00066	48 0f be 00	 movsx	 rax, BYTE PTR [rax]
  0006a	48 89 85 d8 00
	00 00		 mov	 QWORD PTR tv72[rbp], rax
  00071	eb 0b		 jmp	 SHORT $LN7@rawTranscr
$LN6@rawTranscr:
  00073	48 c7 85 d8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tv72[rbp], 0
$LN7@rawTranscr:
  0007e	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00082	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR trg$[rbp]
  00089	48 03 c8	 add	 rcx, rax
  0008c	48 8b c1	 mov	 rax, rcx
  0008f	0f b6 8d d8 00
	00 00		 movzx	 ecx, BYTE PTR tv72[rbp]
  00096	88 08		 mov	 BYTE PTR [rax], cl
  00098	eb 99		 jmp	 SHORT $LN2@rawTranscr
$LN3@rawTranscr:

; 175  : }

  0009a	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000a1	5f		 pop	 rdi
  000a2	5d		 pop	 rbp
  000a3	c3		 ret	 0
rawTranscribe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tHelpers.c
;	COMDAT stringTranscribe
_TEXT	SEGMENT
seek$ = 4
trg$ = 256
src$ = 264
stringTranscribe PROC					; COMDAT

; 162  : void stringTranscribe(char* trg, char* src) {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A1BF244C_tHelpers@c
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 163  : 	int seek = 0;

  00024	c7 45 04 00 00
	00 00		 mov	 DWORD PTR seek$[rbp], 0
$LN2@stringTran:

; 164  : 	while (src[seek] != '\0') {

  0002b	48 63 45 04	 movsxd	 rax, DWORD PTR seek$[rbp]
  0002f	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR src$[rbp]
  00036	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0003a	85 c0		 test	 eax, eax
  0003c	74 28		 je	 SHORT $LN3@stringTran

; 165  : 		trg[seek] = src[seek];

  0003e	48 63 45 04	 movsxd	 rax, DWORD PTR seek$[rbp]
  00042	48 63 4d 04	 movsxd	 rcx, DWORD PTR seek$[rbp]
  00046	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR trg$[rbp]
  0004d	4c 8b 85 08 01
	00 00		 mov	 r8, QWORD PTR src$[rbp]
  00054	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00059	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 166  : 		seek++;

  0005c	8b 45 04	 mov	 eax, DWORD PTR seek$[rbp]
  0005f	ff c0		 inc	 eax
  00061	89 45 04	 mov	 DWORD PTR seek$[rbp], eax

; 167  : 	}

  00064	eb c5		 jmp	 SHORT $LN2@stringTran
$LN3@stringTran:

; 168  : 	trg[seek] = '\0';

  00066	48 63 45 04	 movsxd	 rax, DWORD PTR seek$[rbp]
  0006a	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR trg$[rbp]
  00071	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 169  : }

  00075	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0007c	5f		 pop	 rdi
  0007d	5d		 pop	 rbp
  0007e	c3		 ret	 0
stringTranscribe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tHelpers.c
;	COMDAT paramCount0
_TEXT	SEGMENT
paramCount$ = 4
scopeLevel$ = 36
i$1 = 72
tv76 = 276
tv72 = 276
params$ = 320
paramCount0 PROC					; COMDAT

; 133  : {

$LN22:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A1BF244C_tHelpers@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 134  : 	if (params[0] == '\0')

  0001f	b8 01 00 00 00	 mov	 eax, 1
  00024	48 6b c0 00	 imul	 rax, rax, 0
  00028	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR params$[rbp]
  0002f	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00033	85 c0		 test	 eax, eax
  00035	75 07		 jne	 SHORT $LN7@paramCount

; 135  : 		return 0;

  00037	33 c0		 xor	 eax, eax
  00039	e9 c4 00 00 00	 jmp	 $LN1@paramCount
$LN7@paramCount:

; 136  : 	int paramCount = 1;

  0003e	c7 45 04 01 00
	00 00		 mov	 DWORD PTR paramCount$[rbp], 1

; 137  : 	int scopeLevel = 0;

  00045	c7 45 24 00 00
	00 00		 mov	 DWORD PTR scopeLevel$[rbp], 0

; 138  : 	for (char* i = (char*)params; *i != '\0'; i++)

  0004c	48 8b 85 40 01
	00 00		 mov	 rax, QWORD PTR params$[rbp]
  00053	48 89 45 48	 mov	 QWORD PTR i$1[rbp], rax
  00057	eb 0b		 jmp	 SHORT $LN4@paramCount
$LN2@paramCount:
  00059	48 8b 45 48	 mov	 rax, QWORD PTR i$1[rbp]
  0005d	48 ff c0	 inc	 rax
  00060	48 89 45 48	 mov	 QWORD PTR i$1[rbp], rax
$LN4@paramCount:
  00064	48 8b 45 48	 mov	 rax, QWORD PTR i$1[rbp]
  00068	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0006b	85 c0		 test	 eax, eax
  0006d	0f 84 8c 00 00
	00		 je	 $LN3@paramCount

; 139  : 		switch (*i)

  00073	48 8b 45 48	 mov	 rax, QWORD PTR i$1[rbp]
  00077	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0007a	89 85 14 01 00
	00		 mov	 DWORD PTR tv72[rbp], eax
  00080	8b 85 14 01 00
	00		 mov	 eax, DWORD PTR tv72[rbp]
  00086	83 e8 28	 sub	 eax, 40			; 00000028H
  00089	89 85 14 01 00
	00		 mov	 DWORD PTR tv72[rbp], eax
  0008f	83 bd 14 01 00
	00 55		 cmp	 DWORD PTR tv72[rbp], 85	; 00000055H
  00096	77 62		 ja	 SHORT $LN5@paramCount
  00098	48 63 85 14 01
	00 00		 movsxd	 rax, DWORD PTR tv72[rbp]
  0009f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000a6	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN20@paramCount[rcx+rax]
  000ae	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN21@paramCount[rcx+rax*4]
  000b5	48 03 c1	 add	 rax, rcx
  000b8	ff e0		 jmp	 rax
$LN8@paramCount:
$LN9@paramCount:
$LN10@paramCount:
$LN11@paramCount:

; 140  : 		{
; 141  : 		case '{':
; 142  : 		case '(':
; 143  : 		case '[':
; 144  : 		case '<':
; 145  : 			scopeLevel++;

  000ba	8b 45 24	 mov	 eax, DWORD PTR scopeLevel$[rbp]
  000bd	ff c0		 inc	 eax
  000bf	89 45 24	 mov	 DWORD PTR scopeLevel$[rbp], eax

; 146  : 			break;

  000c2	eb 36		 jmp	 SHORT $LN5@paramCount
$LN12@paramCount:
$LN13@paramCount:
$LN14@paramCount:
$LN15@paramCount:

; 147  : 
; 148  : 		case '}':
; 149  : 		case ')':
; 150  : 		case ']':
; 151  : 		case '>':
; 152  : 			scopeLevel--;

  000c4	8b 45 24	 mov	 eax, DWORD PTR scopeLevel$[rbp]
  000c7	ff c8		 dec	 eax
  000c9	89 45 24	 mov	 DWORD PTR scopeLevel$[rbp], eax

; 153  : 			break;

  000cc	eb 2c		 jmp	 SHORT $LN5@paramCount
$LN16@paramCount:

; 154  : 
; 155  : 		case ',':
; 156  : 			paramCount += scopeLevel == 0;

  000ce	83 7d 24 00	 cmp	 DWORD PTR scopeLevel$[rbp], 0
  000d2	75 0c		 jne	 SHORT $LN18@paramCount
  000d4	c7 85 14 01 00
	00 01 00 00 00	 mov	 DWORD PTR tv76[rbp], 1
  000de	eb 0a		 jmp	 SHORT $LN19@paramCount
$LN18@paramCount:
  000e0	c7 85 14 01 00
	00 00 00 00 00	 mov	 DWORD PTR tv76[rbp], 0
$LN19@paramCount:
  000ea	8b 85 14 01 00
	00		 mov	 eax, DWORD PTR tv76[rbp]
  000f0	8b 4d 04	 mov	 ecx, DWORD PTR paramCount$[rbp]
  000f3	03 c8		 add	 ecx, eax
  000f5	8b c1		 mov	 eax, ecx
  000f7	89 45 04	 mov	 DWORD PTR paramCount$[rbp], eax
$LN5@paramCount:

; 157  : 			break;
; 158  : 		}

  000fa	e9 5a ff ff ff	 jmp	 $LN2@paramCount
$LN3@paramCount:

; 159  : 	return paramCount;

  000ff	8b 45 04	 mov	 eax, DWORD PTR paramCount$[rbp]
$LN1@paramCount:

; 160  : }

  00102	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  00109	5f		 pop	 rdi
  0010a	5d		 pop	 rbp
  0010b	c3		 ret	 0
$LN21@paramCount:
  0010c	00 00 00 00	 DD	 $LN9@paramCount
  00110	00 00 00 00	 DD	 $LN13@paramCount
  00114	00 00 00 00	 DD	 $LN16@paramCount
  00118	00 00 00 00	 DD	 $LN11@paramCount
  0011c	00 00 00 00	 DD	 $LN15@paramCount
  00120	00 00 00 00	 DD	 $LN10@paramCount
  00124	00 00 00 00	 DD	 $LN14@paramCount
  00128	00 00 00 00	 DD	 $LN8@paramCount
  0012c	00 00 00 00	 DD	 $LN12@paramCount
  00130	00 00 00 00	 DD	 $LN5@paramCount
$LN20@paramCount:
  00134	00		 DB	 0
  00135	01		 DB	 1
  00136	09		 DB	 9
  00137	09		 DB	 9
  00138	02		 DB	 2
  00139	09		 DB	 9
  0013a	09		 DB	 9
  0013b	09		 DB	 9
  0013c	09		 DB	 9
  0013d	09		 DB	 9
  0013e	09		 DB	 9
  0013f	09		 DB	 9
  00140	09		 DB	 9
  00141	09		 DB	 9
  00142	09		 DB	 9
  00143	09		 DB	 9
  00144	09		 DB	 9
  00145	09		 DB	 9
  00146	09		 DB	 9
  00147	09		 DB	 9
  00148	03		 DB	 3
  00149	09		 DB	 9
  0014a	04		 DB	 4
  0014b	09		 DB	 9
  0014c	09		 DB	 9
  0014d	09		 DB	 9
  0014e	09		 DB	 9
  0014f	09		 DB	 9
  00150	09		 DB	 9
  00151	09		 DB	 9
  00152	09		 DB	 9
  00153	09		 DB	 9
  00154	09		 DB	 9
  00155	09		 DB	 9
  00156	09		 DB	 9
  00157	09		 DB	 9
  00158	09		 DB	 9
  00159	09		 DB	 9
  0015a	09		 DB	 9
  0015b	09		 DB	 9
  0015c	09		 DB	 9
  0015d	09		 DB	 9
  0015e	09		 DB	 9
  0015f	09		 DB	 9
  00160	09		 DB	 9
  00161	09		 DB	 9
  00162	09		 DB	 9
  00163	09		 DB	 9
  00164	09		 DB	 9
  00165	09		 DB	 9
  00166	09		 DB	 9
  00167	05		 DB	 5
  00168	09		 DB	 9
  00169	06		 DB	 6
  0016a	09		 DB	 9
  0016b	09		 DB	 9
  0016c	09		 DB	 9
  0016d	09		 DB	 9
  0016e	09		 DB	 9
  0016f	09		 DB	 9
  00170	09		 DB	 9
  00171	09		 DB	 9
  00172	09		 DB	 9
  00173	09		 DB	 9
  00174	09		 DB	 9
  00175	09		 DB	 9
  00176	09		 DB	 9
  00177	09		 DB	 9
  00178	09		 DB	 9
  00179	09		 DB	 9
  0017a	09		 DB	 9
  0017b	09		 DB	 9
  0017c	09		 DB	 9
  0017d	09		 DB	 9
  0017e	09		 DB	 9
  0017f	09		 DB	 9
  00180	09		 DB	 9
  00181	09		 DB	 9
  00182	09		 DB	 9
  00183	09		 DB	 9
  00184	09		 DB	 9
  00185	09		 DB	 9
  00186	09		 DB	 9
  00187	07		 DB	 7
  00188	09		 DB	 9
  00189	08		 DB	 8
paramCount0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tHelpers.c
;	COMDAT paramCount
_TEXT	SEGMENT
count$ = 4
rawArray$ = 256
checkArray$ = 264
paramCount PROC						; COMDAT

; 119  : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A1BF244C_tHelpers@c
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 120  : 	unsigned int count = 0;

  00024	c7 45 04 00 00
	00 00		 mov	 DWORD PTR count$[rbp], 0
$LN2@paramCount:

; 121  : 
; 122  : 	while (true)

  0002b	33 c0		 xor	 eax, eax
  0002d	83 f8 01	 cmp	 eax, 1
  00030	74 2c		 je	 SHORT $LN3@paramCount

; 123  : 	{
; 124  : 		if (rawArray[count] != checkArray[count])

  00032	8b 45 04	 mov	 eax, DWORD PTR count$[rbp]
  00035	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR rawArray$[rbp]
  0003c	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00040	8b 4d 04	 mov	 ecx, DWORD PTR count$[rbp]
  00043	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR checkArray$[rbp]
  0004a	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  0004e	3b c1		 cmp	 eax, ecx
  00050	74 02		 je	 SHORT $LN4@paramCount

; 125  : 			break;

  00052	eb 0a		 jmp	 SHORT $LN3@paramCount
$LN4@paramCount:

; 126  : 		count++;

  00054	8b 45 04	 mov	 eax, DWORD PTR count$[rbp]
  00057	ff c0		 inc	 eax
  00059	89 45 04	 mov	 DWORD PTR count$[rbp], eax

; 127  : 	}

  0005c	eb cd		 jmp	 SHORT $LN2@paramCount
$LN3@paramCount:

; 128  : 
; 129  : 	return count;

  0005e	8b 45 04	 mov	 eax, DWORD PTR count$[rbp]

; 130  : }

  00061	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00068	5f		 pop	 rdi
  00069	5d		 pop	 rbp
  0006a	c3		 ret	 0
paramCount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tHelpers.c
;	COMDAT findSubString
_TEXT	SEGMENT
seek$ = 4
sub$ = 256
src$ = 264
findSubString PROC					; COMDAT

; 105  : int findSubString(const char* sub, const char* src) {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A1BF244C_tHelpers@c
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 106  : 
; 107  : 	int seek = 0;

  00024	c7 45 04 00 00
	00 00		 mov	 DWORD PTR seek$[rbp], 0
$LN2@findSubStr:

; 108  : 
; 109  : 	while (src[seek] != '\0') {

  0002b	48 63 45 04	 movsxd	 rax, DWORD PTR seek$[rbp]
  0002f	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR src$[rbp]
  00036	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0003a	85 c0		 test	 eax, eax
  0003c	74 26		 je	 SHORT $LN3@findSubStr

; 110  : 
; 111  : 		if (defaultSubStringCompare(sub, src))

  0003e	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR src$[rbp]
  00045	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR sub$[rbp]
  0004c	e8 00 00 00 00	 call	 defaultSubStringCompare
  00051	85 c0		 test	 eax, eax
  00053	74 05		 je	 SHORT $LN4@findSubStr

; 112  : 			return seek;

  00055	8b 45 04	 mov	 eax, DWORD PTR seek$[rbp]
  00058	eb 0f		 jmp	 SHORT $LN1@findSubStr
$LN4@findSubStr:

; 113  : 			seek++;

  0005a	8b 45 04	 mov	 eax, DWORD PTR seek$[rbp]
  0005d	ff c0		 inc	 eax
  0005f	89 45 04	 mov	 DWORD PTR seek$[rbp], eax

; 114  : 	}

  00062	eb c7		 jmp	 SHORT $LN2@findSubStr
$LN3@findSubStr:

; 115  : 	return -1;

  00064	b8 ff ff ff ff	 mov	 eax, -1
$LN1@findSubStr:

; 116  : }

  00069	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00070	5f		 pop	 rdi
  00071	5d		 pop	 rbp
  00072	c3		 ret	 0
findSubString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tHelpers.c
;	COMDAT findSubStringCustom
_TEXT	SEGMENT
sub$ = 224
src$ = 232
compare$ = 240
findSubStringCustom PROC				; COMDAT

; 92   : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A1BF244C_tHelpers@c
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 93   : 	//int seek = 0;
; 94   : 	//
; 95   : 	//while (src[seek] != '\0') {
; 96   : 	//
; 97   : 	//	if (compare(Request_Compare())
; 98   : 	//		return seek;
; 99   : 	//	seek++;
; 100  : 	//}
; 101  : 	return -1;

  00029	b8 ff ff ff ff	 mov	 eax, -1

; 102  : }

  0002e	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00035	5f		 pop	 rdi
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
findSubStringCustom ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tHelpers.c
;	COMDAT FloatingCompare
_TEXT	SEGMENT
request$ = 224
FloatingCompare PROC					; COMDAT

; 84   : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A1BF244C_tHelpers@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 85   : 	//long double* left = ((long double*)request._src);
; 86   : 	//long double* right = ((long double*)request._trg);
; 87   : 	//
; 88   : 	//return left[request._srcIx] > right[request._trgIx] ? 1 : left[request._srcIx] < right[request._trgIx] ? -1 : 0;
; 89   : }

  0001f	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00026	5f		 pop	 rdi
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
FloatingCompare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tHelpers.c
;	COMDAT SignedIntegralCompare
_TEXT	SEGMENT
request$ = 224
SignedIntegralCompare PROC				; COMDAT

; 76   : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A1BF244C_tHelpers@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 77   : 	//llong* left = ((llong*)request._src);
; 78   : 	//llong* right = ((llong*)request._trg);
; 79   : 	//
; 80   : 	//return left[request._srcIx] > right[request._trgIx] ? 1 : left[request._srcIx] < right[request._trgIx] ? -1 : 0;
; 81   : }

  0001f	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00026	5f		 pop	 rdi
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
SignedIntegralCompare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tHelpers.c
;	COMDAT UnsignedIntegralCompare
_TEXT	SEGMENT
request$ = 224
UnsignedIntegralCompare PROC				; COMDAT

; 68   : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A1BF244C_tHelpers@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 69   : 	//ullong* left = ((ullong*)request._src);
; 70   : 	//ullong* right = ((ullong*)request._trg);
; 71   : 	//
; 72   : 	//return left[request._srcIx] > right[request._trgIx] ? 1 : left[request._srcIx] < right[request._trgIx] ? -1 : 0;
; 73   : }

  0001f	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00026	5f		 pop	 rdi
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
UnsignedIntegralCompare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tHelpers.c
;	COMDAT defaultStringCompare
_TEXT	SEGMENT
seek$ = 4
tv84 = 212
sub$ = 256
str$ = 264
defaultStringCompare PROC				; COMDAT

; 57   : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A1BF244C_tHelpers@c
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 58   : 	int seek = 0;

  00024	c7 45 04 00 00
	00 00		 mov	 DWORD PTR seek$[rbp], 0
$LN2@defaultStr:

; 59   : 	while (sub[seek] != '\0') {

  0002b	48 63 45 04	 movsxd	 rax, DWORD PTR seek$[rbp]
  0002f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR sub$[rbp]
  00036	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0003a	85 c0		 test	 eax, eax
  0003c	74 30		 je	 SHORT $LN3@defaultStr

; 60   : 		if (sub[seek] != str[seek])

  0003e	48 63 45 04	 movsxd	 rax, DWORD PTR seek$[rbp]
  00042	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR sub$[rbp]
  00049	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0004d	48 63 4d 04	 movsxd	 rcx, DWORD PTR seek$[rbp]
  00051	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR str$[rbp]
  00058	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  0005c	3b c1		 cmp	 eax, ecx
  0005e	74 04		 je	 SHORT $LN4@defaultStr

; 61   : 			return false;

  00060	33 c0		 xor	 eax, eax
  00062	eb 39		 jmp	 SHORT $LN1@defaultStr
$LN4@defaultStr:

; 62   : 		seek++;

  00064	8b 45 04	 mov	 eax, DWORD PTR seek$[rbp]
  00067	ff c0		 inc	 eax
  00069	89 45 04	 mov	 DWORD PTR seek$[rbp], eax

; 63   : 	}

  0006c	eb bd		 jmp	 SHORT $LN2@defaultStr
$LN3@defaultStr:

; 64   : 	return str[seek] == '\0';

  0006e	48 63 45 04	 movsxd	 rax, DWORD PTR seek$[rbp]
  00072	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR str$[rbp]
  00079	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0007d	85 c0		 test	 eax, eax
  0007f	75 0c		 jne	 SHORT $LN6@defaultStr
  00081	c7 85 d4 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv84[rbp], 1
  0008b	eb 0a		 jmp	 SHORT $LN7@defaultStr
$LN6@defaultStr:
  0008d	c7 85 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv84[rbp], 0
$LN7@defaultStr:
  00097	8b 85 d4 00 00
	00		 mov	 eax, DWORD PTR tv84[rbp]
$LN1@defaultStr:

; 65   : }

  0009d	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000a4	5f		 pop	 rdi
  000a5	5d		 pop	 rbp
  000a6	c3		 ret	 0
defaultStringCompare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tHelpers.c
;	COMDAT defaultCharCompare
_TEXT	SEGMENT
request$ = 224
defaultCharCompare PROC					; COMDAT

; 41   : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A1BF244C_tHelpers@c
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 42   : 	//return ((char*)request._src)[request._srcIx] == ((char*)request._trg)[request._trgIx];
; 43   : }

  0001f	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00026	5f		 pop	 rdi
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
defaultCharCompare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tHelpers.c
;	COMDAT pow
_TEXT	SEGMENT
output$ = 4
i$1 = 36
base$ = 288
power$ = 296
pow	PROC						; COMDAT

; 33   : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	55		 push	 rbp
  00009	57		 push	 rdi
  0000a	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  00011	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A1BF244C_tHelpers@c
  0001d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 34   : 	int output = 1;

  00022	c7 45 04 01 00
	00 00		 mov	 DWORD PTR output$[rbp], 1

; 35   : 	for (unsigned int i = 0; i < power; i++)

  00029	c7 45 24 00 00
	00 00		 mov	 DWORD PTR i$1[rbp], 0
  00030	eb 08		 jmp	 SHORT $LN4@pow
$LN2@pow:
  00032	8b 45 24	 mov	 eax, DWORD PTR i$1[rbp]
  00035	ff c0		 inc	 eax
  00037	89 45 24	 mov	 DWORD PTR i$1[rbp], eax
$LN4@pow:
  0003a	8b 85 28 01 00
	00		 mov	 eax, DWORD PTR power$[rbp]
  00040	39 45 24	 cmp	 DWORD PTR i$1[rbp], eax
  00043	73 0f		 jae	 SHORT $LN3@pow

; 36   : 		output *= base;

  00045	8b 45 04	 mov	 eax, DWORD PTR output$[rbp]
  00048	0f af 85 20 01
	00 00		 imul	 eax, DWORD PTR base$[rbp]
  0004f	89 45 04	 mov	 DWORD PTR output$[rbp], eax
  00052	eb de		 jmp	 SHORT $LN2@pow
$LN3@pow:

; 37   : 	return output;

  00054	8b 45 04	 mov	 eax, DWORD PTR output$[rbp]

; 38   : }

  00057	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  0005e	5f		 pop	 rdi
  0005f	5d		 pop	 rbp
  00060	c3		 ret	 0
pow	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tHelpers.c
;	COMDAT ClampInt
_TEXT	SEGMENT
tv67 = 192
tv66 = 196
value$ = 240
min$ = 248
max$ = 256
ClampInt PROC						; COMDAT

; 28   : {

$LN7:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	55		 push	 rbp
  0000e	57		 push	 rdi
  0000f	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00016	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A1BF244C_tHelpers@c
  00022	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 29   : 	value = value < min ? min : value > max ? max : value;

  00027	8b 85 f8 00 00
	00		 mov	 eax, DWORD PTR min$[rbp]
  0002d	39 85 f0 00 00
	00		 cmp	 DWORD PTR value$[rbp], eax
  00033	7d 0e		 jge	 SHORT $LN5@ClampInt
  00035	8b 85 f8 00 00
	00		 mov	 eax, DWORD PTR min$[rbp]
  0003b	89 85 c0 00 00
	00		 mov	 DWORD PTR tv67[rbp], eax
  00041	eb 34		 jmp	 SHORT $LN6@ClampInt
$LN5@ClampInt:
  00043	8b 85 00 01 00
	00		 mov	 eax, DWORD PTR max$[rbp]
  00049	39 85 f0 00 00
	00		 cmp	 DWORD PTR value$[rbp], eax
  0004f	7e 0e		 jle	 SHORT $LN3@ClampInt
  00051	8b 85 00 01 00
	00		 mov	 eax, DWORD PTR max$[rbp]
  00057	89 85 c4 00 00
	00		 mov	 DWORD PTR tv66[rbp], eax
  0005d	eb 0c		 jmp	 SHORT $LN4@ClampInt
$LN3@ClampInt:
  0005f	8b 85 f0 00 00
	00		 mov	 eax, DWORD PTR value$[rbp]
  00065	89 85 c4 00 00
	00		 mov	 DWORD PTR tv66[rbp], eax
$LN4@ClampInt:
  0006b	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR tv66[rbp]
  00071	89 85 c0 00 00
	00		 mov	 DWORD PTR tv67[rbp], eax
$LN6@ClampInt:
  00077	8b 85 c0 00 00
	00		 mov	 eax, DWORD PTR tv67[rbp]
  0007d	89 85 f0 00 00
	00		 mov	 DWORD PTR value$[rbp], eax

; 30   : }

  00083	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0008a	5f		 pop	 rdi
  0008b	5d		 pop	 rbp
  0008c	c3		 ret	 0
ClampInt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tHelpers.c
;	COMDAT Clamp
_TEXT	SEGMENT
tv67 = 192
tv66 = 196
value$ = 240
min$ = 248
max$ = 256
Clamp	PROC						; COMDAT

; 23   : {

$LN7:
  00000	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  00006	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  0000c	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00012	55		 push	 rbp
  00013	57		 push	 rdi
  00014	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0001b	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A1BF244C_tHelpers@c
  00027	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 24   : 	value = value < min ? min : value > max ? max : value;

  0002c	f3 0f 10 85 f8
	00 00 00	 movss	 xmm0, DWORD PTR min$[rbp]
  00034	0f 2f 85 f0 00
	00 00		 comiss	 xmm0, DWORD PTR value$[rbp]
  0003b	76 12		 jbe	 SHORT $LN5@Clamp
  0003d	f3 0f 10 85 f8
	00 00 00	 movss	 xmm0, DWORD PTR min$[rbp]
  00045	f3 0f 11 85 c0
	00 00 00	 movss	 DWORD PTR tv67[rbp], xmm0
  0004d	eb 43		 jmp	 SHORT $LN6@Clamp
$LN5@Clamp:
  0004f	f3 0f 10 85 f0
	00 00 00	 movss	 xmm0, DWORD PTR value$[rbp]
  00057	0f 2f 85 00 01
	00 00		 comiss	 xmm0, DWORD PTR max$[rbp]
  0005e	76 12		 jbe	 SHORT $LN3@Clamp
  00060	f3 0f 10 85 00
	01 00 00	 movss	 xmm0, DWORD PTR max$[rbp]
  00068	f3 0f 11 85 c4
	00 00 00	 movss	 DWORD PTR tv66[rbp], xmm0
  00070	eb 10		 jmp	 SHORT $LN4@Clamp
$LN3@Clamp:
  00072	f3 0f 10 85 f0
	00 00 00	 movss	 xmm0, DWORD PTR value$[rbp]
  0007a	f3 0f 11 85 c4
	00 00 00	 movss	 DWORD PTR tv66[rbp], xmm0
$LN4@Clamp:
  00082	f3 0f 10 85 c4
	00 00 00	 movss	 xmm0, DWORD PTR tv66[rbp]
  0008a	f3 0f 11 85 c0
	00 00 00	 movss	 DWORD PTR tv67[rbp], xmm0
$LN6@Clamp:
  00092	f3 0f 10 85 c0
	00 00 00	 movss	 xmm0, DWORD PTR tv67[rbp]
  0009a	f3 0f 11 85 f0
	00 00 00	 movss	 DWORD PTR value$[rbp], xmm0

; 25   : }

  000a2	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  000a9	5f		 pop	 rdi
  000aa	5d		 pop	 rbp
  000ab	c3		 ret	 0
Clamp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Repos\BarrelTest\tHelpers.c
;	COMDAT CreateRequest
_TEXT	SEGMENT
i$4 = 52
seek$ = 84
index$5 = 116
ptr$6 = 152
__$ReturnAddress$ = 400
type$ = 408
params$ = 416
buffer$ = 424
CreateRequest PROC					; COMDAT

; 4    : {

$LN8:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	57		 push	 rdi
  00015	48 81 ec 98 01
	00 00		 sub	 rsp, 408		; 00000198H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00026	b9 2e 00 00 00	 mov	 ecx, 46			; 0000002eH
  0002b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00030	f3 ab		 rep stosd
  00032	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR [rsp+440]
  0003a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__A1BF244C_tHelpers@c
  00041	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 5    : 	REQUEST output = { type, buffer };

  00046	48 8b 85 90 01
	00 00		 mov	 rax, QWORD PTR __$ReturnAddress$[rbp]
  0004d	8b 8d 98 01 00
	00		 mov	 ecx, DWORD PTR type$[rbp]
  00053	89 08		 mov	 DWORD PTR [rax], ecx
  00055	48 8b 85 90 01
	00 00		 mov	 rax, QWORD PTR __$ReturnAddress$[rbp]
  0005c	48 8b 8d a8 01
	00 00		 mov	 rcx, QWORD PTR buffer$[rbp]
  00063	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 6    : 
; 7    : 	for (int i = 0; i < MaxParamCount; i++)

  00067	c7 45 34 00 00
	00 00		 mov	 DWORD PTR i$4[rbp], 0
  0006e	eb 08		 jmp	 SHORT $LN4@CreateRequ
$LN2@CreateRequ:
  00070	8b 45 34	 mov	 eax, DWORD PTR i$4[rbp]
  00073	ff c0		 inc	 eax
  00075	89 45 34	 mov	 DWORD PTR i$4[rbp], eax
$LN4@CreateRequ:
  00078	83 7d 34 10	 cmp	 DWORD PTR i$4[rbp], 16
  0007c	7d 15		 jge	 SHORT $LN3@CreateRequ

; 8    : 		buffer[i] = NONE;

  0007e	48 63 45 34	 movsxd	 rax, DWORD PTR i$4[rbp]
  00082	48 8b 8d a8 01
	00 00		 mov	 rcx, QWORD PTR buffer$[rbp]
  00089	48 c7 04 c1 fe
	ff ff ff	 mov	 QWORD PTR [rcx+rax*8], -2
  00091	eb dd		 jmp	 SHORT $LN2@CreateRequ
$LN3@CreateRequ:

; 9    : 
; 10   : 	uint seek = 0;

  00093	c7 45 54 00 00
	00 00		 mov	 DWORD PTR seek$[rbp], 0
$LN5@CreateRequ:

; 11   : 
; 12   : 	while (params[seek]._type > -1 && params[seek]._type < MaxParamCount) {

  0009a	8b 45 54	 mov	 eax, DWORD PTR seek$[rbp]
  0009d	48 6b c0 10	 imul	 rax, rax, 16
  000a1	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR params$[rbp]
  000a8	83 3c 01 ff	 cmp	 DWORD PTR [rcx+rax], -1
  000ac	7e 62		 jle	 SHORT $LN6@CreateRequ
  000ae	8b 45 54	 mov	 eax, DWORD PTR seek$[rbp]
  000b1	48 6b c0 10	 imul	 rax, rax, 16
  000b5	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR params$[rbp]
  000bc	83 3c 01 10	 cmp	 DWORD PTR [rcx+rax], 16
  000c0	7d 4e		 jge	 SHORT $LN6@CreateRequ

; 13   : 		int index = params[seek]._type;

  000c2	8b 45 54	 mov	 eax, DWORD PTR seek$[rbp]
  000c5	48 6b c0 10	 imul	 rax, rax, 16
  000c9	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR params$[rbp]
  000d0	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  000d3	89 45 74	 mov	 DWORD PTR index$5[rbp], eax

; 14   : 		void* ptr = params[seek]._ptr;;

  000d6	8b 45 54	 mov	 eax, DWORD PTR seek$[rbp]
  000d9	48 6b c0 10	 imul	 rax, rax, 16
  000dd	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR params$[rbp]
  000e4	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  000e9	48 89 85 98 00
	00 00		 mov	 QWORD PTR ptr$6[rbp], rax

; 15   : 		buffer[index] = ptr;

  000f0	48 63 45 74	 movsxd	 rax, DWORD PTR index$5[rbp]
  000f4	48 8b 8d a8 01
	00 00		 mov	 rcx, QWORD PTR buffer$[rbp]
  000fb	48 8b 95 98 00
	00 00		 mov	 rdx, QWORD PTR ptr$6[rbp]
  00102	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 16   : 		seek++;

  00106	8b 45 54	 mov	 eax, DWORD PTR seek$[rbp]
  00109	ff c0		 inc	 eax
  0010b	89 45 54	 mov	 DWORD PTR seek$[rbp], eax

; 17   : 	}

  0010e	eb 8a		 jmp	 SHORT $LN5@CreateRequ
$LN6@CreateRequ:

; 18   : 	//buffer[seek] = NULL;
; 19   : 	return output;

  00110	48 8b 85 90 01
	00 00		 mov	 rax, QWORD PTR __$ReturnAddress$[rbp]

; 20   : }

  00117	48 8b f8	 mov	 rdi, rax
  0011a	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  0011e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:CreateRequest$rtcFrameData
  00125	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0012a	48 8b c7	 mov	 rax, rdi
  0012d	48 8d a5 78 01
	00 00		 lea	 rsp, QWORD PTR [rbp+376]
  00134	5f		 pop	 rdi
  00135	5d		 pop	 rbp
  00136	c3		 ret	 0
CreateRequest ENDP
_TEXT	ENDS
END
